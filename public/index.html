<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°äº”ç›®ä¸¦ã¹ ONLINE</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* CSS èª¿æ•´ */
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #eef2f7; color: #333; height: 100vh; overflow: hidden; display: flex; justify-content: center; }
        
        .container { background: white; width: 100vw; max-width: 500px; height: 100vh; display: flex; flex-direction: column; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.1); }

        /* ãƒ­ãƒ“ãƒ¼ç”»é¢ */
        #lobbyScreen { flex: 1; padding: 25px; overflow-y: auto; display: flex; flex-direction: column; }
        .logo { text-align: center; margin-bottom: 30px; }
        .logo h1 { font-size: 24px; color: #2c3e50; }
        
        .create-box { background: #f8fafc; border: 1px solid #e2e8f0; padding: 20px; border-radius: 12px; margin-bottom: 30px; }
        .create-box h3 { margin-bottom: 15px; font-size: 16px; }
        
        input, select { width: 100%; padding: 12px; margin: 8px 0; border: 1px solid #cbd5e1; border-radius: 8px; font-size: 16px; outline: none; }
        input:focus { border-color: #3b82f6; }

        .btn { padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px; transition: background 0.2s; }
        .btn:hover { background: #2563eb; }
        .btn:disabled { background: #94a3b8; cursor: not-allowed; }

        .room-list-area { flex: 1; }
        .room-item { background: white; border: 1px solid #e2e8f0; padding: 15px; border-radius: 10px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .room-item:hover { border-color: #3b82f6; background: #f0f9ff; }
        .room-info b { font-size: 16px; display: block; }
        .room-info span { font-size: 12px; color: #64748b; }

        /* ã‚²ãƒ¼ãƒ ç”»é¢ */
        #gameScreen { display: none; flex: 1; flex-direction: column; }
        .game-header { padding: 10px 15px; background: white; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; }
        #timerBox { font-size: 24px; font-weight: bold; color: #e11d48; min-width: 60px; text-align: right; }
        
        #canvasWrapper { flex: 1; position: relative; background: #14532d; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        /* æ“ä½œãƒ‘ãƒãƒ« */
        .game-footer { padding: 15px; background: white; border-top: 1px solid #ddd; }
        .direction-selector { display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; }
        .dir-btn { width: 50px; height: 50px; border: 2px solid #cbd5e1; background: white; border-radius: 10px; font-size: 20px; font-weight: bold; }
        .dir-btn.active { border-color: #3b82f6; background: #eff6ff; color: #3b82f6; }

        .game-info-line { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #475569; }

        /* æ„Ÿæƒ³æˆ¦ç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        #reviewPanel { display: none; margin-top: 15px; padding-top: 15px; border-top: 2px dashed #e2e8f0; text-align: center; }
        .rev-btn { padding: 8px 20px; background: #475569; color: white; border: none; border-radius: 6px; font-weight: bold; margin: 0 5px; }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center; }
        .modal-overlay.show { display: flex; }
        .modal-body { background: white; padding: 30px; border-radius: 16px; width: 85%; max-width: 350px; text-align: center; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div class="container">
    <div id="lobbyScreen">
        <div class="logo">
            <h1>ãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°äº”ç›®ä¸¦ã¹</h1>
            <p><small>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ã‚·ã‚¹ãƒ†ãƒ </small></p>
        </div>

        <div class="create-box">
            <h3>æ–°ã—ãå¯¾å±€ã‚’ä½œã‚‹</h3>
            <input type="text" id="inputRoomId" placeholder="ãƒ«ãƒ¼ãƒ åã‚’å…¥åŠ›">
            <input type="password" id="inputPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆä»»æ„ï¼‰">
            <select id="selectTime">
                <option value="10">åˆ¶é™æ™‚é–“: 10ç§’</option>
                <option value="30" selected>åˆ¶é™æ™‚é–“: 30ç§’</option>
                <option value="60">åˆ¶é™æ™‚é–“: 60ç§’</option>
                <option value="free">åˆ¶é™æ™‚é–“ãªã—</option>
            </select>
            <button class="btn" style="width: 100%;" onclick="requestCreateRoom()">ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
        </div>

        <div class="room-list-area">
            <h3 style="margin-bottom:10px; font-size:16px;">é€²è¡Œä¸­ã®ãƒ«ãƒ¼ãƒ </h3>
            <div id="roomListContainer">
                </div>
        </div>
    </div>

    <div id="gameScreen">
        <div class="game-header">
            <div>
                <b id="displayRoomId">Room Name</b><br>
                <span id="displayStatus" style="font-size: 12px; color: #64748b;">å¯¾æˆ¦ç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™...</span>
            </div>
            <div id="timerBox">--</div>
        </div>

        <div id="canvasWrapper">
            <canvas id="mainCanvas"></canvas>
        </div>

        <div class="game-footer">
            <div class="direction-selector" id="dirBtns">
                <button class="dir-btn active" onclick="setDirection(0)">â†‘</button>
                <button class="dir-btn" onclick="setDirection(1)">â†’</button>
                <button class="dir-btn" onclick="setDirection(2)">â†“</button>
                <button class="dir-btn" onclick="setDirection(3)">â†</button>
            </div>

            <div class="game-info-line">
                <span id="pairStatus">é€£ç¶šå¯¾: é»’0/3 ç™½0/3</span>
                <button onclick="location.reload()" style="background:none; border:none; color:#ef4444; font-weight:bold; cursor:pointer;">é€€å‡ºã™ã‚‹</button>
            </div>

            <div id="reviewPanel">
                <p style="margin-bottom:10px; font-weight:bold;">æ„Ÿæƒ³æˆ¦ãƒ¢ãƒ¼ãƒ‰</p>
                <button class="rev-btn" onclick="stepReview(-1)">â—€ å‰ã®æ‰‹</button>
                <span id="reviewStepLabel" style="font-family: monospace; font-weight:bold;">0 / 0</span>
                <button class="rev-btn" onclick="stepReview(1)">æ¬¡ã®æ‰‹ â–¶</button>
            </div>
        </div>
    </div>
</div>

<div id="gameModal" class="modal-overlay">
    <div class="modal-body">
        <h2 id="modalTitle">å¯¾å±€çµ‚äº†</h2>
        <p id="modalText" style="margin: 15px 0; color: #475569;"></p>
        <button class="btn" style="width: 100%; margin-bottom: 10px;" onclick="enableReviewMode()">æ„Ÿæƒ³æˆ¦ã‚’é–‹å§‹</button>
        <button class="btn" style="width: 100%; background: #94a3b8;" onclick="location.reload()">ãƒ­ãƒ“ãƒ¼ã¸æˆ»ã‚‹</button>
    </div>
</div>

<script>
    const socket = io();
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    
    // å®šæ•°ãƒ»ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    const GRID_SIZE = 128;
    const CELL_SIZE = 40;
    
    let myRoomId = "";
    let myPlayerIndex = null; // 0:é»’, 1:ç™½
    let pieces = [];          // ç¾åœ¨ã®ç›¤é¢
    let history = [];         // æ„Ÿæƒ³æˆ¦ç”¨ã®å…¨å±¥æ­´
    let currentTurn = 0;      // ä»Šã©ã£ã¡ã®ç•ªã‹
    let consecutivePairs = [0, 0];
    
    let viewportX = 64;       // ã‚«ãƒ¡ãƒ©ã®ä¸­å¿ƒåº§æ¨™
    let viewportY = 64;
    let zoomScale = 1.0;
    
    let selectedDirection = 0; // 0:ä¸Š, 1:å³, 2:ä¸‹, 3:å·¦
    let isReviewMode = false;
    let reviewPointer = 0;
    let gameStarted = false;

    // --- ãƒ«ãƒ¼ãƒ ãƒªã‚¹ãƒˆç®¡ç† ---
    socket.on('updateRoomList', (list) => {
        const container = document.getElementById('roomListContainer');
        container.innerHTML = "";
        
        if (list.length === 0) {
            container.innerHTML = "<p style='color:#94a3b8; font-size:14px;'>ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ«ãƒ¼ãƒ ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>";
            return;
        }

        list.forEach(room => {
            const item = document.createElement('div');
            item.className = "room-item";
            const passIcon = room.hasPassword ? "ğŸ”’" : "";
            item.innerHTML = `
                <div class="room-info">
                    <b>${room.id} ${passIcon}</b>
                    <span>çŠ¶æ…‹: ${room.status} (${room.playerCount}/2äºº)</span>
                </div>
                <button class="btn" style="padding: 5px 15px; font-size:14px;" ${room.playerCount >= 2 ? 'disabled' : ''}>å‚åŠ </button>
            `;
            item.onclick = () => {
                if(room.playerCount < 2) requestJoinRoom(room.id, room.hasPassword);
            };
            container.appendChild(item);
        });
    });

    // --- é€šä¿¡å‡¦ç† ---
    function requestCreateRoom() {
        const rid = document.getElementById('inputRoomId').value;
        const pass = document.getElementById('inputPassword').value;
        const time = document.getElementById('selectTime').value;
        if (!rid) return alert("ãƒ«ãƒ¼ãƒ åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        
        socket.emit('createRoom', {
            roomId: rid,
            password: pass,
            settings: { timeLimit: time }
        });
    }

    function requestJoinRoom(rid, hasPass) {
        let pass = "";
        if (hasPass) {
            pass = prompt("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            if (pass === null) return;
        }
        socket.emit('joinRoom', { roomId: rid, password: pass });
    }

    socket.on('roomJoined', (data) => {
        myRoomId = data.roomId;
        myPlayerIndex = data.playerIndex;
        document.getElementById('lobbyScreen').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'flex';
        document.getElementById('displayRoomId').textContent = "Room: " + myRoomId;
        
        resizeCanvas();
        centerCamera(64, 64);
    });

    socket.on('gameStart', () => {
        gameStarted = true;
        updateStatusLabel();
        render();
    });

    socket.on('moveMade', (data) => {
        const { piece, nextTurn, consecutivePairs: pairs } = data;
        
        pieces.push(piece);
        history.push({...piece});
        currentTurn = nextTurn;
        consecutivePairs = pairs;

        // ç›¸æ‰‹ãŒæ‰“ã£ãŸãªã‚‰ã€ãã®å ´æ‰€ã«ã‚«ãƒ¡ãƒ©ã‚’é£›ã°ã™
        if (piece.player !== myPlayerIndex) {
            centerCamera(piece.x, piece.y);
        }

        updateStatusLabel();
        render();
    });

    socket.on('timerUpdate', (time) => {
        document.getElementById('timerBox').textContent = time + "s";
    });

    socket.on('gameOver', (data) => {
        gameStarted = false;
        const modal = document.getElementById('gameModal');
        const title = document.getElementById('modalTitle');
        const text = document.getElementById('modalText');

        if (data.winner === -1) {
            title.textContent = "å¼•ãåˆ†ã‘";
            text.textContent = "ç›¤é¢ãŒã„ã£ã±ã„ã§ã™ã€‚";
        } else {
            const isWin = data.winner === myPlayerIndex;
            title.textContent = isWin ? "ã‚ãªãŸã®å‹åˆ©ï¼" : "ã‚ãªãŸã®æ•—åŒ—...";
            text.textContent = data.reason === "timeout" ? "æ™‚é–“åˆ‡ã‚Œã«ã‚ˆã‚Šæ±ºç€ã—ã¾ã—ãŸã€‚" : "äº”ç›®ä¸¦ã³ãŒæˆç«‹ã—ã¾ã—ãŸã€‚";
        }
        modal.classList.add('show');
    });

    socket.on('error_msg', (msg) => alert(msg));
    socket.on('playerLeft', () => {
        alert("å¯¾æˆ¦ç›¸æ‰‹ãŒé€€å‡ºã—ã¾ã—ãŸã€‚ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚Šã¾ã™ã€‚");
        location.reload();
    });

    // --- ã‚²ãƒ¼ãƒ æç”»ãƒ­ã‚¸ãƒƒã‚¯ ---
    function centerCamera(gx, gy) {
        viewportX = gx;
        viewportY = gy;
    }

    function render() {
        if (!canvas.width) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const currentSize = CELL_SIZE * zoomScale;
        const offsetX = canvas.width / 2 - viewportX * currentSize;
        const offsetY = canvas.height / 2 - viewportY * currentSize;

        // èƒŒæ™¯ï¼ˆç·‘ã®å¸ƒé¢ï¼‰
        ctx.fillStyle = "#166534";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç›¤é¢ã®æ 
        ctx.fillStyle = "#14532d";
        ctx.fillRect(offsetX, offsetY, GRID_SIZE * currentSize, GRID_SIZE * currentSize);

        // ã‚°ãƒªãƒƒãƒ‰ç·šã®æç”»
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= GRID_SIZE; i++) {
            // ç¸¦ç·š
            ctx.moveTo(offsetX + i * currentSize, offsetY);
            ctx.lineTo(offsetX + i * currentSize, offsetY + GRID_SIZE * currentSize);
            // æ¨ªç·š
            ctx.moveTo(offsetX, offsetY + i * currentSize);
            ctx.lineTo(offsetX + GRID_SIZE * currentSize, offsetY + i * currentSize);
        }
        ctx.stroke();

        // é§’ã®æç”»
        const drawList = isReviewMode ? history.slice(0, reviewPointer) : pieces;

        drawList.forEach((p, idx) => {
            const px = offsetX + p.x * currentSize + currentSize / 2;
            const py = offsetY + p.y * currentSize + currentSize / 2;

            // ç”»é¢å¤–ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ã—ã¦æç”»è² è·è»½æ¸›
            if (px < -currentSize || px > canvas.width + currentSize || py < -currentSize || py > canvas.height + currentSize) return;

            // ãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°ã®æç”»
            ctx.beginPath();
            ctx.arc(px, py, currentSize * 0.35, 0, Math.PI * 2);
            ctx.strokeStyle = (p.player === 0) ? "#000000" : "#ffffff";
            ctx.lineWidth = currentSize * 0.12;
            ctx.stroke();

            // åˆ‡ã‚Œç›®ï¼ˆé»„è‰²ã„ç·šã§è¡¨ç¾ï¼‰
            ctx.beginPath();
            const angleMap = [-Math.PI/2, 0, Math.PI/2, Math.PI]; // ä¸Š, å³, ä¸‹, å·¦
            const startA = angleMap[p.direction] - 0.4;
            const endA = angleMap[p.direction] + 0.4;
            ctx.arc(px, py, currentSize * 0.35, startA, endA);
            ctx.strokeStyle = "#fbbf24";
            ctx.lineWidth = currentSize * 0.14;
            ctx.stroke();
            
            // æœ€æ–°ã®æ‰‹ã‚’å¼·èª¿
            if (!isReviewMode && idx === pieces.length - 1) {
                ctx.beginPath();
                ctx.arc(px, py, currentSize * 0.45, 0, Math.PI * 2);
                ctx.strokeStyle = "rgba(251, 191, 36, 0.5)";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });

        // ã€Œå¯¾ã€ã®æˆç«‹ç·šã‚’èµ¤ãè¡¨ç¤º
        drawList.forEach((p1, i) => {
            for (let j = i + 1; j < drawList.length; j++) {
                const p2 = drawList[j];
                if (p1.player === p2.player && checkFacingEachOther(p1, p2)) {
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(offsetX + p1.x * currentSize + currentSize / 2, offsetY + p1.y * currentSize + currentSize / 2);
                    ctx.lineTo(offsetX + p2.x * currentSize + currentSize / 2, offsetY + p2.y * currentSize + currentSize / 2);
                    ctx.strokeStyle = "rgba(239, 68, 68, 0.8)";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        });
    }

    // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯è£œåŠ© ---
    function checkFacingEachOther(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        if (Math.abs(dx) > 1 || Math.abs(dy) > 1) return false;

        // p1ã‹ã‚‰è¦‹ã¦p2ãŒã©ã“ã«ã„ã¦ã€å‘ããŒåˆã£ã¦ã„ã‚‹ã‹
        if (dx === 0 && dy === -1) return p1.direction === 0 && p2.direction === 2; // p2ãŒä¸Šã§ã€p1ä¸ŠãŒå‘ãã€p2ä¸‹ãŒå‘ã
        if (dx === 1 && dy === 0)  return p1.direction === 1 && p2.direction === 3; // p2ãŒå³
        if (dx === 0 && dy === 1)  return p1.direction === 2 && p2.direction === 0; // p2ãŒä¸‹
        if (dx === -1 && dy === 0) return p1.direction === 3 && p2.direction === 1; // p2ãŒå·¦
        return false;
    }

    function updateStatusLabel() {
        const label = document.getElementById('displayStatus');
        if (!gameStarted) {
            label.textContent = "å¯¾æˆ¦ç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™...";
            return;
        }
        const colorName = currentTurn === 0 ? "é»’" : "ç™½";
        if (currentTurn === myPlayerIndex) {
            label.textContent = `â˜… ã‚ãªãŸã®ç•ªã§ã™ (${colorName})`;
            label.style.color = "#3b82f6";
        } else {
            label.textContent = `ç›¸æ‰‹ãŒè€ƒãˆã¦ã„ã¾ã™... (${colorName})`;
            label.style.color = "#64748b";
        }
        document.getElementById('pairStatus').textContent = `é€£ç¶šå¯¾: é»’${consecutivePairs[0]}/3 ç™½${consecutivePairs[1]}/3`;
    }

    function setDirection(dir) {
        selectedDirection = dir;
        const btns = document.querySelectorAll('.dir-btn');
        btns.forEach((b, i) => b.classList.toggle('active', i === dir));
    }

    // é§’ã‚’ç½®ããƒ¡ã‚¤ãƒ³å‡¦ç†
    function handleClick(screenX, screenY) {
        if (!gameStarted || currentTurn !== myPlayerIndex || isReviewMode) return;

        const currentSize = CELL_SIZE * zoomScale;
        const offsetX = canvas.width / 2 - viewportX * currentSize;
        const offsetY = canvas.height / 2 - viewportY * currentSize;

        const gx = Math.floor((screenX - offsetX) / currentSize);
        const gy = Math.floor((screenY - offsetY) / currentSize);

        // ç¯„å›²å¤–ãƒã‚§ãƒƒã‚¯
        if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return;
        // é‡è¤‡ãƒã‚§ãƒƒã‚¯
        if (pieces.find(p => p.x === gx && p.y === gy)) return;

        // ã€Œå¯¾ã€ã®ãƒã‚§ãƒƒã‚¯
        let isPairAction = false;
        const lastOpponentPiece = pieces.filter(p => p.player !== myPlayerIndex).slice(-1)[0];
        if (lastOpponentPiece) {
            const dx = gx - lastOpponentPiece.x;
            const dy = gy - lastOpponentPiece.y;
            // ç›¸æ‰‹ã®åˆ‡ã‚Œç›®ã®å…ˆã«ç½®ã“ã†ã¨ã—ã¦ã„ã‚‹ã‹
            if ((lastOpponentPiece.direction === 0 && dx === 0 && dy === -1) ||
                (lastOpponentPiece.direction === 1 && dx === 1 && dy === 0) ||
                (lastOpponentPiece.direction === 2 && dx === 0 && dy === 1) ||
                (lastOpponentPiece.direction === 3 && dx === -1 && dy === 0)) {
                isPairAction = true;
            }
        }

        if (isPairAction && consecutivePairs[myPlayerIndex] >= 3) {
            alert("4å›é€£ç¶šã§ã€å¯¾ã€ã‚’ä½œã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ï¼");
            return;
        }

        // é€£æ‰“ãƒã‚°é˜²æ­¢ã®ãŸã‚ã€é€ä¿¡ç›´å‰ã«ã‚¿ãƒ¼ãƒ³ã‚’ç„¡åŠ¹åŒ–
        const tempTurn = currentTurn;
        currentTurn = -1; 

        const newPiece = { x: gx, y: gy, direction: selectedDirection, player: myPlayerIndex };
        const newConsecutive = [...consecutivePairs];
        newConsecutive[myPlayerIndex] = isPairAction ? newConsecutive[myPlayerIndex] + 1 : 0;

        socket.emit('placePiece', {
            roomId: myRoomId,
            piece: newPiece,
            consecutivePairs: newConsecutive
        });

        // å‹åˆ©åˆ¤å®š
        if (localWinCheck(pieces.concat(newPiece), myPlayerIndex)) {
            socket.emit('declareWin', { roomId: myRoomId, winner: myPlayerIndex, reason: "checkmate" });
        }
    }

    function localWinCheck(allPieces, pIdx) {
        const myPieces = allPieces.filter(p => p.player === pIdx);
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
        
        for (let p of myPieces) {
            for (let [dx, dy] of directions) {
                let count = 1;
                let line = [p];
                // 5æ–¹å‘é€£ç¶šã‚’ãƒã‚§ãƒƒã‚¯
                for (let step = 1; step < 5; step++) {
                    const found = myPieces.find(target => target.x === p.x + dx * step && target.y === p.y + dy * step);
                    if (found) {
                        count++;
                        line.push(found);
                    } else break;
                }
                if (count >= 5) {
                    // ãã®5åˆ—ã®ä¸­ã«ã€Œå¯¾ã€ãŒ1ã¤ã§ã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ã‹
                    for (let pieceA of line) {
                        for (let pieceB of myPieces) {
                            if (pieceA !== pieceB && checkFacingEachOther(pieceA, pieceB)) return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    // --- æ„Ÿæƒ³æˆ¦æ©Ÿèƒ½ ---
    function enableReviewMode() {
        document.getElementById('gameModal').classList.remove('show');
        isReviewMode = true;
        reviewPointer = history.length;
        document.getElementById('reviewPanel').style.display = 'block';
        document.getElementById('dirBtns').style.display = 'none';
        updateReviewUI();
        render();
    }

    function stepReview(dir) {
        reviewPointer += dir;
        if (reviewPointer < 0) reviewPointer = 0;
        if (reviewPointer > history.length) reviewPointer = history.length;
        
        if (reviewPointer > 0) {
            const lastP = history[reviewPointer - 1];
            centerCamera(lastP.x, lastP.y);
        }
        updateReviewUI();
        render();
    }

    function updateReviewUI() {
        document.getElementById('reviewStepLabel').textContent = `${reviewPointer} / ${history.length}`;
    }

    // --- å…¥åŠ›ãƒ»æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆ ---
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let pinchStartDist = 0;

    canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0) { // å³ãƒ»ä¸­å¤®ã‚¯ãƒªãƒƒã‚¯ã§ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const dx = (e.clientX - lastMouseX) / (CELL_SIZE * zoomScale);
            const dy = (e.clientY - lastMouseY) / (CELL_SIZE * zoomScale);
            viewportX -= dx;
            viewportY -= dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            render();
        }
    });

    window.addEventListener('mouseup', () => isDragging = false);

    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        handleClick(e.clientX - rect.left, e.clientY - rect.top);
    });

    // ã‚¿ãƒƒãƒæ“ä½œï¼ˆãƒ‰ãƒ©ãƒƒã‚°ãƒ»ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ãƒ»ã‚¿ãƒƒãƒ—ç€æ‰‹ï¼‰
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = false; // ã‚¿ãƒƒãƒ—ã‹ç§»å‹•ã‹ã®åˆ¤åˆ¥ç”¨
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            pinchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
            isDragging = true;
            const dx = (e.touches[0].clientX - lastMouseX) / (CELL_SIZE * zoomScale);
            const dy = (e.touches[0].clientY - lastMouseY) / (CELL_SIZE * zoomScale);
            viewportX -= dx;
            viewportY -= dy;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            render();
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const factor = dist / pinchStartDist;
            zoomScale = Math.min(Math.max(0.5, zoomScale * factor), 3.0);
            pinchStartDist = dist;
            render();
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        if (!isDragging && e.changedTouches.length === 1) {
            const rect = canvas.getBoundingClientRect();
            const t = e.changedTouches[0];
            handleClick(t.clientX - rect.left, t.clientY - rect.top);
        }
    });

    // ãƒ›ã‚¤ãƒ¼ãƒ«ã‚ºãƒ¼ãƒ 
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomScale = Math.min(Math.max(0.5, zoomScale * delta), 3.0);
        render();
    }, { passive: false });

    function resizeCanvas() {
        const wrapper = document.getElementById('canvasWrapper');
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        render();
    }
    window.addEventListener('resize', resizeCanvas);

</script>
</body>
</html>


