<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LANDOLT ONLINE GOMOKU</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* === CSS DESIGN SYSTEM === */
        :root {
            --bg-color: #0f172a;
            --surface-color: #ffffff;
            --primary: #2563eb;
            --secondary: #16a34a;
            --danger: #ef4444;
            --text-main: #1e293b;
            --text-sub: #64748b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            height: 100vh;
            display: flex;
            justify-content: center;
            overflow: hidden; /* å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¦æ­¢ */
        }

        .app-container {
            width: 100%;
            max-width: 500px;
            height: 100%;
            background-color: var(--surface-color);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* --- LOBBY SECTION --- */
        #lobby-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        .lobby-header { margin-bottom: 20px; text-align: center; }
        .lobby-header h1 { font-size: 24px; font-weight: 800; color: var(--text-main); }

        .create-room-panel {
            background-color: #f1f5f9;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; font-size: 12px; font-weight: bold; color: var(--text-sub); margin-bottom: 4px; }
        input {
            width: 100%;
            padding: 12px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
        }
        input:focus { border-color: var(--primary); }

        .btn-primary {
            width: 100%;
            padding: 12px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
        }

        /* ãƒ«ãƒ¼ãƒ ãƒªã‚¹ãƒˆã‚¨ãƒªã‚¢ï¼ˆã“ã“ã ã‘ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ã«ã™ã‚‹ï¼‰ */
        .room-list-container {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 10px;
            background-color: #fff;
            touch-action: pan-y; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®ã¿è¨±å¯ */
        }

        .room-card {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .room-info b { font-size: 16px; color: var(--text-main); display: block; }
        .room-info span { font-size: 12px; color: var(--text-sub); }

        .btn-join {
            background-color: var(--secondary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
        }

        /* --- GAME SECTION --- */
        #game-view {
            display: none; /* åˆæœŸã¯éè¡¨ç¤º */
            flex-direction: column;
            height: 100%;
            touch-action: none; /* ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å®Œå…¨ã«ç¦æ­¢ */
        }

        .game-nav {
            padding: 10px 15px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
        }
        .game-nav b { font-size: 18px; color: var(--text-main); }
        .game-nav #status-badge { font-size: 12px; font-weight: bold; padding: 4px 8px; border-radius: 4px; background: #e2e8f0; }

        #canvas-container {
            flex: 1;
            background-color: #064e3b;
            position: relative;
            overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; }

        .game-controls {
            padding: 20px;
            padding-bottom: 45px; /* iOSã®ã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢å¯¾å¿œ */
            background-color: #fff;
            border-top: 1px solid #e2e8f0;
        }

        .direction-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .dir-btn {
            height: 60px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .dir-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: scale(0.95);
        }

        .exit-btn {
            width: 100%;
            padding: 10px;
            font-size: 22px;
            font-weight: 800;
            color: var(--danger);
            border: none;
            background: none;
            cursor: pointer;
        }

        /* è£œåŠ©è¡¨ç¤º */
        #pair-counter {
            text-align: center;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

<div class="app-container">
    <div id="lobby-view">
        <div class="lobby-header">
            <h1>LANDOLT ONLINE</h1>
        </div>

        <div class="create-room-panel">
            <div class="input-group">
                <label>ROOM NAME</label>
                <input type="text" id="input-room-id" placeholder="ãƒ«ãƒ¼ãƒ åã‚’å…¥åŠ›">
            </div>
            <div class="input-group">
                <label>PASSWORD (Optional)</label>
                <input type="password" id="input-room-pw" placeholder="ç©ºæ¬„ãªã‚‰ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—">
            </div>
            <button class="btn-primary" onclick="handleCreateRoom()">æ–°ã—ãå¯¾å±€ã‚’ä½œã‚‹</button>
        </div>

        <div style="margin-bottom: 10px;">
            <input type="text" id="search-input" placeholder="ğŸ” ãƒ«ãƒ¼ãƒ ã‚’æ¤œç´¢..." oninput="refreshRoomListUI()">
        </div>

        <div class="room-list-container" id="room-list-target">
            </div>
    </div>

    <div id="game-view">
        <div class="game-nav">
            <div>
                <b id="display-room-name">---</b><br>
                <span id="display-turn-info">æ¥ç¶šä¸­...</span>
            </div>
            <div id="status-badge">WAITING</div>
        </div>

        <div id="pair-counter">PAIRS: 0 / 0</div>

        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
        </div>

        <div class="game-controls">
            <div class="direction-selector">
                <div class="dir-btn active" id="dir-0" onclick="changeDirection(0)">â†‘</div>
                <div class="dir-btn" id="dir-1" onclick="changeDirection(1)">â†’</div>
                <div class="dir-btn" id="dir-2" onclick="changeDirection(2)">â†“</div>
                <div class="dir-btn" id="dir-3" onclick="changeDirection(3)">â†</div>
            </div>
            <button class="exit-btn" onclick="confirmExit()">LEAVE GAME</button>
        </div>
    </div>
</div>

<script>
    // === GAME LOGIC / SOCKET COMMUNICATION ===
    const socket = io();
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const canvasContainer = document.getElementById('canvas-container');

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹
    let currentRooms = [];
    let playerIndex = null; // 0 or 1
    let myTurn = false;
    let gameState = {
        roomId: "",
        board: [],
        turn: 0,
        gameStarted: false,
        pairCounts: [0, 0] // é€£ç¶šã®ã€Œå¯¾ã€å›æ•°
    };

    // ã‚«ãƒ¡ãƒ©ãƒ»æ“ä½œçŠ¶æ…‹
    let camera = { x: 64, y: 64, zoom: 1.0 };
    let selectedDir = 0;
    let isDragging = false;
    let lastTouchPos = { x: 0, y: 0 };
    let lastPinchDist = 0;
    let activeTouches = new Map();

    // --- Lobby Functions ---
    socket.on('updateRoomList', (list) => {
        currentRooms = list;
        refreshRoomListUI();
    });

    function refreshRoomListUI() {
        const target = document.getElementById('room-list-target');
        const searchWord = document.getElementById('search-input').value.toLowerCase();
        target.innerHTML = "";

        const filtered = currentRooms.filter(r => r.id.toLowerCase().includes(searchWord));

        if (filtered.length === 0) {
            target.innerHTML = `<p style="text-align:center; padding:20px; color:#94a3b8;">ãƒ«ãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</p>`;
            return;
        }

        filtered.forEach(room => {
            const card = document.createElement('div');
            card.className = 'room-card';
            card.innerHTML = `
                <div class="room-info">
                    <b>${room.id} ${room.hasPw ? 'ğŸ”’' : ''}</b>
                    <span>${room.status} (${room.playerCount}/2)</span>
                </div>
                <button class="btn-join" onclick="handleJoinRoom('${room.id}', ${room.hasPw})" ${room.playerCount >= 2 ? 'disabled' : ''}>
                    ${room.playerCount >= 2 ? 'æº€å“¡' : 'å‚åŠ '}
                </button>
            `;
            target.appendChild(card);
        });
    }

    function handleCreateRoom() {
        const roomId = document.getElementById('input-room-id').value;
        const password = document.getElementById('input-room-pw').value;
        if (!roomId) return alert("ãƒ«ãƒ¼ãƒ åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        socket.emit('createRoom', { roomId, password, settings: { timeLimit: 60 } });
    }

    function handleJoinRoom(id, hasPw) {
        const password = hasPw ? prompt("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„") : "";
        if (password !== null) socket.emit('joinRoom', { roomId: id, password });
    }

    // --- Socket Game Events ---
    socket.on('roomJoined', (data) => {
        playerIndex = data.playerIndex;
        gameState.roomId = data.roomId;
        document.getElementById('lobby-view').style.display = 'none';
        document.getElementById('game-view').style.display = 'flex';
        document.getElementById('display-room-name').textContent = data.roomId;
        resizeCanvas();
    });

    socket.on('gameStart', () => {
        gameState.gameStarted = true;
        updateUI();
        render();
    });

    socket.on('moveMade', (data) => {
        gameState.board.push(data.piece);
        gameState.turn = data.nextTurn;
        gameState.pairCounts = data.consecutivePairs;
        updateUI();
        render();
    });

    socket.on('gameOver', (data) => {
        gameState.gameStarted = false;
        alert(data.winner === playerIndex ? "ã‚ãªãŸã®å‹åˆ©ã§ã™ï¼" : "æ•—åŒ—ã—ã¾ã—ãŸ...");
        location.reload();
    });

    socket.on('playerLeft', () => {
        alert("å¯¾æˆ¦ç›¸æ‰‹ãŒé€€å‡ºã—ã¾ã—ãŸã€‚");
        location.reload();
    });

    socket.on('error_msg', (msg) => alert(msg));

    // --- Rendering Engine ---
    function render() {
        if (!canvas.width) return;
        
        // èƒŒæ™¯ã‚¯ãƒªã‚¢
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cellSize = 45 * camera.zoom;
        const offsetX = canvas.width / 2 - camera.x * cellSize;
        const offsetY = canvas.height / 2 - camera.y * cellSize;

        // ç›¤é¢æç”»ï¼ˆ128x128ï¼‰
        ctx.fillStyle = "#064e3b";
        ctx.fillRect(offsetX, offsetY, 128 * cellSize, 128 * cellSize);

        // ã‚°ãƒªãƒƒãƒ‰ç·š
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        // æç”»è² è·è»½æ¸›ã®ãŸã‚ã€ç”»é¢å†…ã®ã¿æç”»ã™ã‚‹å·¥å¤«ã‚‚å¯èƒ½ã ãŒä»Šå›ã¯å…¨æç”»
        for (let i = 0; i <= 128; i++) {
            ctx.moveTo(offsetX + i * cellSize, offsetY);
            ctx.lineTo(offsetX + i * cellSize, offsetY + 128 * cellSize);
            ctx.moveTo(offsetX, offsetY + i * cellSize);
            ctx.lineTo(offsetX + 128 * cellSize, offsetY + i * cellSize);
        }
        ctx.stroke();

        // é§’ï¼ˆãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°ï¼‰ã®æç”»
        gameState.board.forEach(piece => {
            const centerX = offsetX + piece.x * cellSize + cellSize / 2;
            const centerY = offsetY + piece.y * cellSize + cellSize / 2;
            const radius = cellSize * 0.35;

            // å††æœ¬ä½“
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = (piece.player === 0) ? "#000000" : "#ffffff";
            ctx.lineWidth = cellSize * 0.1;
            ctx.stroke();

            // åˆ‡ã‚Œç›®ï¼ˆãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°ã®ç‰¹å¾´ï¼‰
            ctx.beginPath();
            const startAngle = [-Math.PI/2, 0, Math.PI/2, Math.PI][piece.direction];
            ctx.arc(centerX, centerY, radius, startAngle - 0.4, startAngle + 0.4);
            ctx.strokeStyle = "#fbbf24"; // åˆ‡ã‚Œç›®ã‚’ç›®ç«‹ãŸã›ã‚‹è‰²
            ctx.lineWidth = cellSize * 0.13;
            ctx.stroke();
        });
    }

    // --- Interaction Logic (The Most Critical Part) ---
    canvasContainer.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
            isDragging = false;
            lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            activeTouches.set(e.touches[0].identifier, lastTouchPos);
        } else if (e.touches.length === 2) {
            lastPinchDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
        }
    }, { passive: false });

    canvasContainer.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const currentPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const dx = currentPos.x - lastTouchPos.x;
            const dy = currentPos.y - lastTouchPos.y;

            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) isDragging = true;

            // ã‚«ãƒ¡ãƒ©ç§»å‹•
            camera.x -= dx / (45 * camera.zoom);
            camera.y -= dy / (45 * camera.zoom);

            lastTouchPos = currentPos;
            render();
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            const zoomFactor = dist / lastPinchDist;
            camera.zoom = Math.min(Math.max(camera.zoom * zoomFactor, 0.4), 3.0);
            lastPinchDist = dist;
            render();
        }
    }, { passive: false });

    canvasContainer.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (!isDragging && e.changedTouches.length === 1 && e.touches.length === 0) {
            const rect = canvas.getBoundingClientRect();
            const touchX = e.changedTouches[0].clientX - rect.left;
            const touchY = e.changedTouches[0].clientY - rect.top;
            processBoardClick(touchX, touchY);
        }
        for (let t of e.changedTouches) activeTouches.delete(t.identifier);
    }, { passive: false });

    /**
     * ç”»é¢ã‚¿ãƒƒãƒ—ã‚’ç›¤é¢åº§æ¨™ã«å¤‰æ›ã—ã¦çŸ³ã‚’ç½®ã
     */
    function processBoardClick(screenX, screenY) {
        if (!gameState.gameStarted || gameState.turn !== playerIndex) return;

        const cellSize = 45 * camera.zoom;
        const gridX = Math.floor((screenX - (canvas.width / 2 - camera.x * cellSize)) / cellSize);
        const gridY = Math.floor((screenY - (canvas.height / 2 - camera.y * cellSize)) / cellSize);

        // ç¯„å›²å¤–ã¾ãŸã¯æ—¢ã«çŸ³ãŒã‚ã‚‹
        if (gridX < 0 || gridX >= 128 || gridY < 0 || gridY >= 128) return;
        if (gameState.board.some(p => p.x === gridX && p.y === gridY)) return;

        // ã€Œå¯¾ã€ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
        let isPairMove = false;
        const lastOpponentPiece = gameState.board.filter(p => p.player !== playerIndex).pop();
        
        if (lastOpponentPiece) {
            const dx = gridX - lastOpponentPiece.x;
            const dy = gridY - lastOpponentPiece.y;
            // ç›¸æ‰‹ã®åˆ‡ã‚Œç›®ã®æ–¹å‘ã«è‡ªåˆ†ãŒç½®ã„ãŸã‹
            if (lastOpponentPiece.direction === 0 && dy === -1 && dx === 0) isPairMove = true;
            if (lastOpponentPiece.direction === 1 && dx === 1 && dy === 0) isPairMove = true;
            if (lastOpponentPiece.direction === 2 && dy === 1 && dx === 0) isPairMove = true;
            if (lastOpponentPiece.direction === 3 && dx === -1 && dy === 0) isPairMove = true;
        }

        // 3é€£ç¶šåˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (isPairMove && gameState.pairCounts[playerIndex] >= 3) {
            return alert("é€£ç¶šã—ã¦ã€Œå¯¾ã€ã«ã§ãã‚‹ã®ã¯3å›ã¾ã§ã§ã™ï¼");
        }

        const newPairCounts = [...gameState.pairCounts];
        newPairCounts[playerIndex] = isPairMove ? newPairCounts[playerIndex] + 1 : 0;

        const piece = { x: gridX, y: gridY, direction: selectedDir, player: playerIndex };

        // ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
        socket.emit('placePiece', {
            roomId: gameState.roomId,
            piece: piece,
            consecutivePairs: newPairCounts
        });

        // å‹åˆ©åˆ¤å®š
        if (checkWinCondition(gameState.board.concat(piece), playerIndex)) {
            socket.emit('declareWin', { roomId: gameState.roomId, winner: playerIndex });
        }
    }

    /**
     * å‹åˆ©æ¡ä»¶: 5ã¤ä¸¦ã‚“ã§ã„ã‚‹ ï¼‹ ãã®ä¸­ã«æœ€ä½1ã¤ã®ã€Œå¯¾ã€é–¢ä¿‚ãŒå«ã¾ã‚Œã¦ã„ã‚‹
     */
    function checkWinCondition(board, side) {
        const myPieces = board.filter(p => p.player === side);
        const vectors = [[1, 0], [0, 1], [1, 1], [1, -1]];

        for (const p of myPieces) {
            for (const [vx, vy] of vectors) {
                let line = [p];
                // 5ã¤ä¸¦ã³ã‚’ãƒã‚§ãƒƒã‚¯
                for (let i = 1; i < 5; i++) {
                    const found = myPieces.find(m => m.x === p.x + vx * i && m.y === p.y + vy * i);
                    if (found) line.push(found); else break;
                }

                if (line.length >= 5) {
                    // ãã®5ã¤ã®ä¸­ã«ã€ç›¤é¢ä¸Šã®èª°ã‹ã¨ã€Œå¯¾ã€ã«ãªã£ã¦ã„ã‚‹çŸ³ãŒ1ã¤ã§ã‚‚ã‚ã‚‹ã‹ï¼Ÿ
                    const hasValidPair = line.some(stone => {
                        return board.some(other => {
                            if (other === stone) return false;
                            return isPairRelation(stone, other);
                        });
                    });
                    if (hasValidPair) return true;
                }
            }
        }
        return false;
    }

    function isPairRelation(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        if (dx === 0 && dy === -1) return a.direction === 0 && b.direction === 2;
        if (dx === 1 && dy === 0) return a.direction === 1 && b.direction === 3;
        if (dx === 0 && dy === 1) return a.direction === 2 && b.direction === 0;
        if (dx === -1 && dy === 0) return a.direction === 3 && b.direction === 1;
        return false;
    }

    // --- UI Helpers ---
    function updateUI() {
        const badge = document.getElementById('status-badge');
        const info = document.getElementById('display-turn-info');
        
        if (gameState.turn === playerIndex) {
            badge.textContent = "YOUR TURN";
            badge.style.background = "var(--primary)";
            badge.style.color = "white";
            info.textContent = "ã‚ãªãŸã®ç•ªã§ã™ã€‚çŸ³ã‚’ç½®ã„ã¦ãã ã•ã„ã€‚";
        } else {
            badge.textContent = "WAITING";
            badge.style.background = "#e2e8f0";
            badge.style.color = "var(--text-sub)";
            info.textContent = "ç›¸æ‰‹ãŒè€ƒãˆã¦ã„ã¾ã™...";
        }

        document.getElementById('pair-counter').textContent = `PAIRS: ${gameState.pairCounts[0]} / ${gameState.pairCounts[1]}`;
    }

    function changeDirection(d) {
        selectedDir = d;
        document.querySelectorAll('.dir-btn').forEach((btn, i) => {
            btn.classList.toggle('active', i === d);
        });
    }

    function resizeCanvas() {
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;
        render();
    }

    function confirmExit() {
        if (confirm("å¯¾å±€ã‚’çµ‚äº†ã—ã¦ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ")) location.reload();
    }

    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>



