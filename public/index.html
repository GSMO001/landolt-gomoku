<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ランドルト環五目並べ ONLINE</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* 全デバイス共通の基本スタイル */
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { font-family: 'Segoe UI', sans-serif; background: #f3f4f6; display: flex; justify-content: center; min-height: 100vh; overflow: hidden; }
        .container { background: white; width: 100vw; height: 100vh; position: relative; display: flex; flex-direction: column; }

        /* ロビー画面 */
        #lobby { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; text-align: center; background: white; z-index: 100; }
        .lobby-ui { width: 100%; max-width: 320px; }
        input, select { width: 100%; padding: 15px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; }
        .btn { padding: 12px 24px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .btn:active { transform: scale(0.98); }

        /* ゲーム画面 */
        #gameArea { display: none; flex: 1; flex-direction: column; overflow: hidden; }
        .header { padding: 10px 15px; background: white; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; }
        #timerDisplay { font-size: 28px; font-weight: bold; color: #dc2626; }
        #playerStatus { font-size: 13px; font-weight: bold; color: #4b5563; }

        /* メイン盤面 */
        #canvasContainer { flex: 1; position: relative; background: #2d5016; }
        canvas { display: block; width: 100%; height: 100%; }

        /* 下部操作パネル */
        .controls-bottom { padding: 15px; background: white; border-top: 1px solid #ddd; }
        .direction-row { display: flex; justify-content: center; gap: 8px; margin-bottom: 12px; }
        .dir-btn { width: 55px; height: 55px; border: 2px solid #ccc; background: #fff; border-radius: 10px; font-size: 22px; font-weight: bold; }
        .dir-btn.active { border-color: #3b82f6; background: #dbeafe; box-shadow: 0 0 8px rgba(59,130,246,0.3); }

        .info-overlay { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 6px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 10; }

        /* 感想戦 */
        #reviewUI { margin-top: 10px; padding: 15px; background: #f9fafb; border-radius: 10px; text-align: center; }
        
        /* モーダル */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; justify-content: center; align-items: center; }
        .modal.active { display: flex; }
        .modal-content { background: white; padding: 35px; border-radius: 20px; text-align: center; width: 85%; max-width: 380px; }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <div id="lobby">
            <h1 style="margin-bottom:20px;">ランドルト環五目並べ</h1>
            <div class="lobby-ui">
                <input type="text" id="roomName" placeholder="ルーム名を入力">
                <select id="timeLimit">
                    <option value="10">制限時間：10秒</option>
                    <option value="20">制限時間：20秒</option>
                    <option value="30" selected>制限時間：30秒</option>
                    <option value="free">制限なし</option>
                </select>
                <button class="btn" style="width:100%; margin-top:10px;" onclick="createRoom()">新規ルーム作成</button>
                <button class="btn" style="width:100%; margin-top:10px; background:#10b981;" onclick="joinRoom()">参加する</button>
                <p id="errorMsg" style="color:#ef4444; margin-top:15px; font-size:14px; font-weight:bold;"></p>
            </div>
        </div>

        <div id="gameArea">
            <div class="header">
                <div>
                    <strong id="roomTitle" style="font-size:18px;">ルーム</strong>
                    <div id="playerStatus">相手の参加を待っています...</div>
                </div>
                <div id="timerDisplay">--</div>
            </div>

            <div id="canvasContainer">
                <div class="info-overlay">
                    <span id="coordDisplay">座標: (0, 0)</span> | <span id="zoomDisplay">100%</span>
                </div>
                <canvas id="gameCanvas"></canvas>
            </div>

            <div class="controls-bottom">
                <div class="direction-row" id="dirBtnGroup"></div>
                <div style="display:flex; justify-content: space-between; align-items: center;">
                    <div id="pairStatus" style="font-size:12px; color:#4b5563;">連続対: 黒0/3 白0/3</div>
                    <button class="btn" style="padding:6px 15px; background:#6b7280; font-size:14px;" onclick="location.reload()">退出</button>
                </div>

                <div id="reviewUI" class="hidden">
                    <h4 style="margin-bottom:10px;">感想戦モード</h4>
                    <button class="btn" onclick="reviewMove(-1)" style="background:#4b5563">◀ 前の手</button>
                    <span id="reviewStep" style="margin: 0 15px; font-weight:bold;">0 / 0</span>
                    <button class="btn" onclick="reviewMove(1)" style="background:#4b5563">次の手 ▶</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="winModal">
        <div class="modal-content">
            <h1 id="winMsg" style="font-size:32px; margin-bottom:10px;"></h1>
            <p id="winSub" style="font-size:18px; color:#4b5563; margin-bottom:25px;"></p>
            <button class="btn" style="width:100%; margin-bottom:10px;" onclick="startReview()">感想戦を開始</button>
            <button class="btn" style="width:100%; background:#9ca3af;" onclick="location.reload()">ロビーに戻る</button>
        </div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ゲーム状態管理
        let myRoom = "", myIndex = null, pieces = [], history = [];
        let currentPlayer = 0, consecutivePairs = [0, 0];
        let viewportX = 32768 - 10, viewportY = 32768 - 7.5, zoom = 1.0;
        let selectedDir = 0, isReview = false, reviewIndex = 0;

        // 操作用
        let isMoving = false, lastTouchX = 0, lastTouchY = 0, initialDist = 0;

        function resize() {
            const container = document.getElementById('canvasContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        window.addEventListener('resize', resize);

        // --- 通信処理 ---
        function createRoom() {
            const name = document.getElementById('roomName').value;
            const time = document.getElementById('timeLimit').value;
            if(!name) return alert("ルーム名を入力してください");
            socket.emit('createRoom', { roomId: name, settings: { timeLimit: time } });
        }

        function joinRoom() {
            const name = document.getElementById('roomName').value;
            if(!name) return alert("ルーム名を入力してください");
            socket.emit('joinRoom', name);
        }

        socket.on('error_msg', m => document.getElementById('errorMsg').textContent = m);

        socket.on('roomJoined', data => {
            myRoom = data.roomId; myIndex = data.playerIndex;
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('gameArea').style.display = 'flex';
            document.getElementById('roomTitle').textContent = `ルーム: ${myRoom}`;
            initDirectionButtons();
            resize();
        });

        socket.on('gameStart', () => { updateUI(); draw(); });

        socket.on('moveMade', data => {
            pieces.push(data.piece); history.push({...data.piece});
            currentPlayer = data.nextTurn; consecutivePairs = data.consecutivePairs;
            updateUI(); draw();
        });

        socket.on('timerUpdate', t => document.getElementById('timerDisplay').textContent = t + "s");

        socket.on('gameOver', data => {
            document.getElementById('winMsg').textContent = (data.winner === myIndex) ? "勝利！" : "敗北...";
            document.getElementById('winSub').textContent = data.reason === "timeout" ? "制限時間切れです" : "五目が並びました！";
            document.getElementById('winModal').classList.add('active');
        });

        socket.on('playerLeft', () => { alert("対戦相手が退出しました"); location.reload(); });

        // --- 描画ロジック ---
        function initDirectionButtons() {
            const container = document.getElementById('dirBtnGroup');
            ['↑', '→', '↓', '←'].forEach((l, i) => {
                const b = document.createElement('button');
                b.className = `dir-btn ${i===0?'active':''}`;
                b.textContent = l;
                b.onclick = () => {
                    selectedDir = i;
                    document.querySelectorAll('.dir-btn').forEach((btn,idx)=>btn.classList.toggle('active', idx===i));
                };
                container.appendChild(b);
            });
        }

        function updateUI() {
            const turn = (currentPlayer === myIndex) ? "★自分の番です" : "相手が考え中...";
            const color = (currentPlayer === 0) ? "黒" : "白";
            document.getElementById('playerStatus').textContent = `${turn} (${color})`;
            document.getElementById('pairStatus').textContent = `連続対: 黒${consecutivePairs[0]}/3 白${consecutivePairs[1]}/3`;
        }

        function draw() {
            if(!canvas.width) return;
            const size = 40 * zoom;
            ctx.fillStyle = '#2d5016'; ctx.fillRect(0,0,canvas.width, canvas.height);
            
            // グリッド線
            ctx.strokeStyle = 'rgba(26,48,16,0.5)'; ctx.lineWidth = 1;
            const offsetX = (viewportX % 1) * size;
            const offsetY = (viewportY % 1) * size;
            for(let x = -offsetX; x < canvas.width; x += size) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for(let y = -offsetY; y < canvas.height; y += size) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }

            const currentSet = isReview ? history.slice(0, reviewIndex) : pieces;
            
            // 駒の描画
            currentSet.forEach(p => {
                const x = (p.x - viewportX) * size + size/2;
                const y = (p.y - viewportY) * size + size/2;
                if(x < -size || x > canvas.width+size || y < -size || y > canvas.height+size) return;

                ctx.strokeStyle = (p.player === 0) ? '#111' : '#eee';
                ctx.lineWidth = 3.5 * zoom;
                ctx.beginPath(); ctx.arc(x, y, 12*zoom, 0, Math.PI*2); ctx.stroke();
                
                ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 4.5 * zoom;
                ctx.beginPath();
                const angles = [-Math.PI/2, 0, Math.PI/2, Math.PI];
                ctx.arc(x, y, 12*zoom, angles[p.direction]-0.4, angles[p.direction]+0.4);
                ctx.stroke();
            });

            // 対のハイライト（赤い点線）
            currentSet.forEach((p, i) => {
                for(let j=i+1; j<currentSet.length; j++) {
                    const op = currentSet[j];
                    if(p.player === op.player && isFacing(p, op)) {
                        ctx.strokeStyle = 'rgba(239, 68, 68, 0.7)'; ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo((p.x-viewportX)*size+size/2, (p.y-viewportY)*size+size/2);
                        ctx.lineTo((op.x-viewportX)*size+size/2, (op.y-viewportY)*size+size/2);
                        ctx.stroke(); ctx.setLineDash([]);
                    }
                }
            });
        }

        function isFacing(p1, p2) {
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) return false;
            if (dx === 0 && dy === 1) return p1.direction === 2 && p2.direction === 0;
            if (dx === 0 && dy === -1) return p1.direction === 0 && p2.direction === 2;
            if (dx === 1 && dy === 0) return p1.direction === 1 && p2.direction === 3;
            if (dx === -1 && dy === 0) return p1.direction === 3 && p2.direction === 1;
            return false;
        }

        // --- タッチ & マウス操作 ---
        const handleDown = (x, y) => { isMoving = false; lastTouchX = x; lastTouchY = y; };
        const handleMove = (x, y) => {
            isMoving = true;
            viewportX -= (x - lastTouchX) / (40 * zoom);
            viewportY -= (y - lastTouchY) / (40 * zoom);
            lastTouchX = x; lastTouchY = y;
            draw();
        };

        canvas.addEventListener('mousedown', e => { if(e.button !== 0) handleDown(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => {
            const r = canvas.getBoundingClientRect();
            const gx = Math.floor(viewportX + (e.clientX-r.left)/(40*zoom)), gy = Math.floor(viewportY + (e.clientY-r.top)/(40*zoom));
            document.getElementById('coordDisplay').textContent = `座標: (${gx}, ${gy})`;
            if(e.buttons === 2 || e.buttons === 4) handleMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', e => {
            if(e.touches.length === 1) handleDown(e.touches[0].clientX, e.touches[0].clientY);
            else if(e.touches.length === 2) initialDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        }, {passive: false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length === 1) handleMove(e.touches[0].clientX, e.touches[0].clientY);
            else if(e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                if(initialDist > 0) {
                    zoom = Math.max(0.5, Math.min(3, zoom * (dist / initialDist)));
                    initialDist = dist;
                    document.getElementById('zoomDisplay').textContent = Math.round(zoom*100) + "%";
                    draw();
                }
            }
        }, {passive: false});

        canvas.addEventListener('touchend', e => {
            if(!isMoving && e.changedTouches.length === 1 && currentPlayer === myIndex && !isReview) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.changedTouches[0];
                const gx = Math.floor(viewportX + (touch.clientX - rect.left) / (40 * zoom));
                const gy = Math.floor(viewportY + (touch.clientY - rect.top) / (40 * zoom));
                attemptPlace(gx, gy);
            }
            initialDist = 0;
        });

        canvas.addEventListener('click', e => {
            if(e.button === 0 && !isReview && currentPlayer === myIndex) {
                const rect = canvas.getBoundingClientRect();
                const gx = Math.floor(viewportX + (e.clientX - rect.left) / (40 * zoom));
                const gy = Math.floor(viewportY + (e.clientY - rect.top) / (40 * zoom));
                attemptPlace(gx, gy);
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom = Math.max(0.5, Math.min(3, zoom + (e.deltaY < 0 ? 0.1 : -0.1)));
            document.getElementById('zoomDisplay').textContent = Math.round(zoom*100) + "%";
            draw();
        }, {passive: false});

        function attemptPlace(gx, gy) {
            if(pieces.find(p => p.x === gx && p.y === gy)) return;

            let isPair = false;
            const lastOpp = pieces.filter(p => p.player !== myIndex).pop();
            if(lastOpp) {
                const dx = gx - lastOpp.x, dy = gy - lastOpp.y;
                if((lastOpp.direction===0 && dx===0 && dy===-1) || (lastOpp.direction===1 && dx===1 && dy===0) ||
                   (lastOpp.direction===2 && dx===0 && dy===1) || (lastOpp.direction===3 && dx===-1 && dy===0)) isPair = true;
            }
            if(isPair && consecutivePairs[myIndex] >= 3) return alert("4回連続対は禁止です！");

            const piece = { x: gx, y: gy, direction: selectedDir, player: myIndex };
            const nextPairs = [...consecutivePairs];
            nextPairs[myIndex] = isPair ? nextPairs[myIndex] + 1 : 0;

            socket.emit('placePiece', { roomId: myRoom, piece, consecutivePairs: nextPairs });
            if(checkWin(pieces.concat(piece), myIndex)) socket.emit('declareWin', { roomId: myRoom, winner: myIndex });
        }

        function checkWin(pList, pIdx) {
            const myP = pList.filter(p => p.player === pIdx);
            const dList = [[1,0],[0,1],[1,1],[1,-1]];
            for(let p of myP) {
                for(let [dx, dy] of dList) {
                    let line = [p];
                    for(let i=1; i<5; i++) {
                        const t = myP.find(v => v.x === p.x+dx*i && v.y === p.y+dy*i);
                        if(t) line.push(t); else break;
                    }
                    if(line.length >= 5) {
                        for(let lp of line) for(let op of myP) if(lp !== op && isFacing(lp, op)) return true;
                    }
                }
            }
            return false;
        }

        // --- 感想戦 ---
        function startReview() {
            document.getElementById('winModal').classList.remove('active');
            isReview = true; reviewIndex = history.length;
            document.getElementById('reviewUI').classList.remove('hidden');
            updateReviewUI(); draw();
        }
        function reviewMove(dir) {
            reviewIndex = Math.max(0, Math.min(history.length, reviewIndex + dir));
            updateReviewUI(); draw();
        }
        function updateReviewUI() {
            document.getElementById('reviewStep').textContent = `${reviewIndex} / ${history.length} 手目`;
        }
    </script>
</body>
</html>

