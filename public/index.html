<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°äº”ç›®ä¸¦ã¹ ONLINE</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        :root {
            --board-bg: #14532d;
            --ui-bg: #f8fafc;
            --accent: #3b82f6;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            user-select: none;
            touch-action: none; /* é‡è¦: ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’å®Œå…¨ã«æŠ‘åˆ¶ */
        }

        body {
            font-family: -apple-system, sans-serif;
            background: var(--ui-bg);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 600px;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: #fff;
            position: relative;
        }

        /* Lobby */
        #lobby {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .card {
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        input, select, button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            font-size: 16px;
        }

        .btn-main {
            background: var(--accent);
            color: white;
            border: none;
            font-weight: bold;
            cursor: pointer;
        }

        /* Game */
        #game-screen {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .top-bar {
            padding: 10px 20px;
            background: #fff;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #canvas-container {
            flex: 1;
            background: var(--board-bg);
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .controls {
            padding: 15px;
            background: #fff;
            border-top: 1px solid #e2e8f0;
        }

        .dir-grid {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
        }

        .dir-btn {
            width: 50px;
            height: 50px;
            border: 2px solid #e2e8f0;
            background: #fff;
            border-radius: 10px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dir-btn.active {
            border-color: var(--accent);
            background: #eff6ff;
            color: var(--accent);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #fff;
            padding: 30px;
            border-radius: 16px;
            width: 80%;
            max-width: 400px;
            text-align: center;
        }
    </style>
</head>
<body>

<div class="container">
    <div id="lobby">
        <h2 style="margin-bottom:15px">ãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°äº”ç›®ä¸¦ã¹</h2>
        <div class="card">
            <input type="text" id="roomIdIn" placeholder="ãƒ«ãƒ¼ãƒ å">
            <input type="password" id="roomPwIn" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰(ä»»æ„)">
            <select id="timeLimitIn">
                <option value="30">30ç§’</option>
                <option value="60">60ç§’</option>
                <option value="free">ç„¡åˆ¶é™</option>
            </select>
            <button class="btn-main" onclick="createRoom()">ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
        </div>
        <div id="roomList"></div>
    </div>

    <div id="game-screen">
        <div class="top-bar">
            <div>
                <b id="displayRoomId">---</b><br>
                <small id="statusLabel">å¾…æ©Ÿä¸­</small>
            </div>
            <div id="timer" style="font-size: 24px; font-weight: bold; color: var(--danger)">--</div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="controls">
            <div class="dir-grid">
                <div class="dir-btn active" onclick="setDir(0)">â†‘</div>
                <div class="dir-btn" onclick="setDir(1)">â†’</div>
                <div class="dir-btn" onclick="setDir(2)">â†“</div>
                <div class="dir-btn" onclick="setDir(3)">â†</div>
            </div>
            <div id="review-ui" style="display:none; text-align:center; margin-bottom:10px;">
                <button onclick="changeReviewStep(-1)" style="width:auto; padding:5px 15px;">â—€</button>
                <span id="reviewText" style="margin:0 15px; font-weight:bold;">0 / 0</span>
                <button onclick="changeReviewStep(1)" style="width:auto; padding:5px 15px;">â–¶</button>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <span id="pairInfo" style="font-size:12px; font-weight:bold;">é€£ç¶šå¯¾: é»’0 ç™½0</span>
                <button onclick="location.reload()" style="width:auto; padding:5px 15px; background:none; color:var(--danger); border:none;">é€€å‡º</button>
            </div>
        </div>
    </div>
</div>

<div id="modal" class="modal">
    <div class="modal-content">
        <h2 id="modalTitle">å¯¾å±€çµ‚äº†</h2>
        <p id="modalMsg" style="margin: 15px 0; color: #64748b;"></p>
        <button class="btn-main" onclick="startReview()">æ„Ÿæƒ³æˆ¦</button>
        <button class="btn-main" style="background:#64748b; margin-top:10px;" onclick="location.reload()">ãƒ­ãƒ“ãƒ¼ã¸</button>
    </div>
</div>

<script>
    /**
     * LANDOLT GOMOKU - JS ENGINE
     */
    const socket = io();
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');

    const GRID_SIZE = 128;
    const CELL_SIZE = 40;

    let myRoom = "";
    let myIndex = null;
    let board = [];
    let history = [];
    let turn = 0;
    let pairs = [0, 0];
    let isRunning = false;

    // View State
    let camX = 64, camY = 64;
    let scale = 1.0;
    let selectedDir = 0;
    let isReview = false;
    let reviewIdx = 0;

    // --- Lobby Logic ---
    socket.on('updateRoomList', (list) => {
        const area = document.getElementById('roomList');
        area.innerHTML = list.length ? "" : "<p style='text-align:center; color:#94a3b8;'>å‹Ÿé›†ä¸­ã®å¯¾å±€ã¯ã‚ã‚Šã¾ã›ã‚“</p>";
        list.forEach(r => {
            const d = document.createElement('div');
            d.className = "card";
            d.innerHTML = `
                <b>${r.id} ${r.hasPassword ? 'ğŸ”’' : ''}</b><br>
                <small>${r.status} | ${r.playerCount}/2äºº</small>
                <button class="btn-main" onclick="joinRoom('${r.id}', ${r.hasPassword})" ${r.playerCount >= 2 ? 'disabled' : ''}>å‚åŠ </button>
            `;
            area.appendChild(d);
        });
    });

    function createRoom() {
        const id = document.getElementById('roomIdIn').value;
        const pw = document.getElementById('roomPwIn').value;
        const limit = document.getElementById('timeLimitIn').value;
        if(!id) return alert("ãƒ«ãƒ¼ãƒ åå¿…é ˆ");
        socket.emit("createRoom", { roomId: id, password: pw, settings: { timeLimit: limit } });
    }

    function joinRoom(id, hasPw) {
        const pw = hasPw ? prompt("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰") : "";
        socket.emit("joinRoom", { roomId: id, password: pw });
    }

    socket.on('roomJoined', data => {
        myRoom = data.roomId;
        myIndex = data.playerIndex;
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-screen').style.display = 'flex';
        document.getElementById('displayRoomId').textContent = myRoom;
        resize();
        camX = 64; camY = 64;
    });

    socket.on('gameStart', () => {
        isRunning = true;
        updateUI();
        render();
    });

    socket.on('error_msg', m => alert(m));

    // --- Core Game Logic ---
    socket.on('moveMade', data => {
        board.push(data.piece);
        history.push({...data.piece});
        turn = data.nextTurn;
        pairs = data.consecutivePairs;
        if(data.piece.player !== myIndex) { camX = data.piece.x; camY = data.piece.y; }
        updateUI();
        render();
    });

    socket.on('timerUpdate', t => document.getElementById('timer').textContent = t + "s");

    socket.on('gameOver', data => {
        isRunning = false;
        document.getElementById('modal').style.display = 'flex';
        document.getElementById('modalTitle').textContent = data.winner === myIndex ? "å‹åˆ©ï¼" : (data.winner === -1 ? "å¼•ãåˆ†ã‘" : "æ•—åŒ—...");
        document.getElementById('modalMsg').textContent = data.reason === "timeout" ? "æ™‚é–“åˆ‡ã‚Œã«ã‚ˆã‚‹æ±ºç€ã§ã™ã€‚" : "äº”ç›®ä¸¦ã³ï¼ˆå¯¾è¾¼ã¿ï¼‰ãŒæˆç«‹ã—ã¾ã—ãŸã€‚";
    });

    socket.on('playerLeft', () => {
        alert("ç›¸æ‰‹ãŒé€€å‡ºã—ã¾ã—ãŸ");
        location.reload();
    });

    // --- Rendering ---
    function render() {
        if(!canvas.width) return;
        ctx.clearRect(0,0,canvas.width, canvas.height);

        const currentScale = CELL_SIZE * scale;
        const offsetX = canvas.width/2 - camX * currentScale;
        const offsetY = canvas.height/2 - camY * currentScale;

        // Background
        ctx.fillStyle = "#14532d";
        ctx.fillRect(offsetX, offsetY, GRID_SIZE * currentScale, GRID_SIZE * currentScale);

        // Grid
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<=GRID_SIZE; i++) {
            ctx.moveTo(offsetX + i * currentScale, offsetY);
            ctx.lineTo(offsetX + i * currentScale, offsetY + GRID_SIZE * currentScale);
            ctx.moveTo(offsetX, offsetY + i * currentScale);
            ctx.lineTo(offsetX + GRID_SIZE * currentScale, offsetY + i * currentScale);
        }
        ctx.stroke();

        const list = isReview ? history.slice(0, reviewIdx) : board;

        // ã€å¯¾ã®ç‚¹ç·šã€‘æç”»
        list.forEach((p1, i) => {
            for(let j=i+1; j<list.length; j++){
                const p2 = list[j];
                if(p1.player === p2.player && isFacing(p1, p2)){
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = "#ef4444";
                    ctx.lineWidth = 2;
                    ctx.moveTo(offsetX + p1.x * currentScale + currentScale/2, offsetY + p1.y * currentScale + currentScale/2);
                    ctx.lineTo(offsetX + p2.x * currentScale + currentScale/2, offsetY + p2.y * currentScale + currentScale/2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        });

        // é§’
        list.forEach(p => {
            const x = offsetX + p.x * currentScale + currentScale/2;
            const y = offsetY + p.y * currentScale + currentScale/2;
            
            // æœ¬ä½“
            ctx.beginPath();
            ctx.arc(x, y, currentScale*0.35, 0, Math.PI*2);
            ctx.strokeStyle = p.player === 0 ? "#000" : "#fff";
            ctx.lineWidth = currentScale * 0.12;
            ctx.stroke();

            // åˆ‡ã‚Œç›® (Landolt)
            ctx.beginPath();
            const angleMap = [-Math.PI/2, 0, Math.PI/2, Math.PI];
            const start = angleMap[p.direction] - 0.5;
            const end = angleMap[p.direction] + 0.5;
            ctx.arc(x, y, currentScale*0.35, start, end);
            ctx.strokeStyle = "#fbbf24";
            ctx.lineWidth = currentScale * 0.15;
            ctx.stroke();
        });
    }

    function isFacing(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        if(Math.abs(dx) > 1 || Math.abs(dy) > 1) return false;
        if(dx === 0 && dy === -1) return p1.direction === 0 && p2.direction === 2;
        if(dx === 1 && dy === 0) return p1.direction === 1 && p2.direction === 3;
        if(dx === 0 && dy === 1) return p1.direction === 2 && p2.direction === 0;
        if(dx === -1 && dy === 0) return p1.direction === 3 && p2.direction === 1;
        return false;
    }

    // --- Touch & Mouse Logic (Fixed) ---
    let lastT1 = {x:0, y:0}, lastT2 = {x:0, y:0};
    let isDrag = false, isPinch = false;
    let moveThreshold = false;

    // Mouse Events
    canvas.addEventListener('mousedown', e => {
        if(e.button !== 0) return;
        isDrag = true; moveThreshold = false;
        lastT1 = {x: e.clientX, y: e.clientY};
    });
    window.addEventListener('mousemove', e => {
        if(!isDrag) return;
        const dx = e.clientX - lastT1.x;
        const dy = e.clientY - lastT1.y;
        if(Math.abs(dx) > 2 || Math.abs(dy) > 2) moveThreshold = true;
        camX -= dx / (CELL_SIZE * scale);
        camY -= dy / (CELL_SIZE * scale);
        lastT1 = {x: e.clientX, y: e.clientY};
        render();
    });
    window.addEventListener('mouseup', () => isDrag = false);

    canvas.addEventListener('click', e => {
        if(moveThreshold) return;
        const rect = canvas.getBoundingClientRect();
        handleAction(e.clientX - rect.left, e.clientY - rect.top);
    });

    // Touch Events (Fully Controlled)
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        moveThreshold = false;
        if(e.touches.length === 1) {
            isDrag = true; isPinch = false;
            lastT1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        } else if(e.touches.length === 2) {
            isDrag = false; isPinch = true;
            lastT1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
            lastT2 = {x: e.touches[1].clientX, y: e.touches[1].clientY};
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if(isDrag && e.touches.length === 1) {
            const dx = e.touches[0].clientX - lastT1.x;
            const dy = e.touches[0].clientY - lastT1.y;
            if(Math.abs(dx) > 5 || Math.abs(dy) > 5) moveThreshold = true;
            camX -= dx / (CELL_SIZE * scale);
            camY -= dy / (CELL_SIZE * scale);
            lastT1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        } else if(isPinch && e.touches.length === 2) {
            moveThreshold = true;
            const dPrev = Math.hypot(lastT1.x - lastT2.x, lastT1.y - lastT2.y);
            const dCurr = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const ratio = dCurr / dPrev;
            scale = Math.max(0.4, Math.min(scale * ratio, 4.0));
            lastT1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
            lastT2 = {x: e.touches[1].clientX, y: e.touches[1].clientY};
        }
        render();
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        e.preventDefault();
        if(!moveThreshold && !isPinch && isDrag) {
            const rect = canvas.getBoundingClientRect();
            const t = e.changedTouches[0];
            handleAction(t.clientX - rect.left, t.clientY - rect.top);
        }
        isDrag = false; isPinch = false;
    }, {passive: false});

    function handleAction(sx, sy) {
        if(!isRunning || turn !== myIndex || isReview) return;

        const currentScale = CELL_SIZE * scale;
        const offsetX = canvas.width/2 - camX * currentScale;
        const offsetY = canvas.height/2 - camY * currentScale;

        const gx = Math.floor((sx - offsetX) / currentScale);
        const gy = Math.floor((sy - offsetY) / currentScale);

        if(gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return;
        if(board.find(p => p.x === gx && p.y === gy)) return;

        // Pair Check
        let isPair = false;
        const oppPieces = board.filter(p => p.player !== myIndex);
        const lastOpp = oppPieces[oppPieces.length - 1];
        if(lastOpp) {
            const dx = gx - lastOpp.x;
            const dy = gy - lastOpp.y;
            if((lastOpp.direction === 0 && dy === -1) || (lastOpp.direction === 1 && dx === 1) ||
               (lastOpp.direction === 2 && dy === 1) || (lastOpp.direction === 3 && dx === -1)) isPair = true;
        }

        if(isPair && pairs[myIndex] >= 3) return alert("é€£ç¶šå¯¾ã¯3å›ã¾ã§ã§ã™");

        const nextPairs = [...pairs];
        nextPairs[myIndex] = isPair ? nextPairs[myIndex] + 1 : 0;

        const newPiece = { x: gx, y: gy, direction: selectedDir, player: myIndex };
        
        // ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ (ã“ã“ã‚’å…ˆã«é€ã‚‹ã“ã¨ã§ã€ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”ã§activeTurnãŒæ›´æ–°ã•ã‚Œã‚‹ã®ã‚’å¾…ã¤)
        socket.emit("placePiece", { roomId: myRoom, piece: newPiece, consecutivePairs: nextPairs });

        if(checkWin(board.concat(newPiece), myIndex)) {
            socket.emit("declareWin", { roomId: myRoom, winner: myIndex });
        }
    }

    function checkWin(all, pIdx) {
        const mine = all.filter(p => p.player === pIdx);
        const dirs = [[1,0],[0,1],[1,1],[1,-1]];
        for(let p of mine) {
            for(let [dx, dy] of dirs) {
                let count = 1;
                let line = [p];
                for(let i=1; i<5; i++) {
                    const found = mine.find(m => m.x === p.x + dx*i && m.y === p.y + dy*i);
                    if(found) { count++; line.push(found); } else break;
                }
                if(count >= 5) {
                    for(let l1 of line) {
                        for(let l2 of all) { if(l1 !== l2 && isFacing(l1, l2)) return true; }
                    }
                }
            }
        }
        return false;
    }

    // --- Helpers ---
    function setDir(d) {
        selectedDir = d;
        document.querySelectorAll('.dir-btn').forEach((b, i) => b.classList.toggle('active', i === d));
    }

    function updateUI() {
        const lbl = document.getElementById('statusLabel');
        lbl.textContent = turn === myIndex ? "â˜… ã‚ãªãŸã®ç•ª" : "ç›¸æ‰‹ã®ç•ª";
        lbl.style.color = turn === myIndex ? "var(--accent)" : "#64748b";
        document.getElementById('pairInfo').textContent = `é€£ç¶šå¯¾: é»’${pairs[0]} ç™½${pairs[1]}`;
    }

    function startReview() {
        document.getElementById('modal').style.display = 'none';
        isReview = true;
        reviewIdx = history.length;
        document.getElementById('review-ui').style.display = 'block';
        updateReview();
        render();
    }

    function changeReviewStep(d) {
        reviewIdx = Math.max(0, Math.min(history.length, reviewIdx + d));
        updateReview();
        render();
    }

    function updateReview() {
        document.getElementById('reviewText').textContent = `${reviewIdx} / ${history.length}`;
    }

    function resize() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        render();
    }

    window.addEventListener('resize', resize);
</script>
</body>
</html>





