<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ランドルト環五目並べ ONLINE</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { font-family: 'Segoe UI', sans-serif; background: #f3f4f6; display: flex; justify-content: center; min-height: 100vh; overflow: hidden; }
        .container { background: white; width: 100vw; height: 100vh; position: relative; display: flex; flex-direction: column; }

        /* ロビー画面 */
        #lobby { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; text-align: center; background: white; z-index: 100; }
        .lobby-ui { width: 100%; max-width: 320px; }
        input, select { width: 100%; padding: 15px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; }
        .btn { padding: 12px 24px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }

        /* ゲーム画面 */
        #gameArea { display: none; flex: 1; flex-direction: column; overflow: hidden; }
        .header { padding: 10px 15px; background: white; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; }
        #timerDisplay { font-size: 28px; font-weight: bold; color: #dc2626; }
        #playerStatus { font-size: 13px; font-weight: bold; color: #4b5563; }

        /* メイン盤面 */
        #canvasContainer { flex: 1; position: relative; background: #2d5016; }
        canvas { display: block; width: 100%; height: 100%; }

        /* 下部パネル */
        .controls-bottom { padding: 15px; background: white; border-top: 1px solid #ddd; }
        .direction-row { display: flex; justify-content: center; gap: 8px; margin-bottom: 12px; }
        .dir-btn { width: 55px; height: 55px; border: 2px solid #ccc; background: #fff; border-radius: 10px; font-size: 22px; font-weight: bold; }
        .dir-btn.active { border-color: #3b82f6; background: #dbeafe; }

        .info-overlay { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 6px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 10; }

        #reviewUI { margin-top: 10px; padding: 15px; background: #f9fafb; border-radius: 10px; text-align: center; }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; justify-content: center; align-items: center; }
        .modal.active { display: flex; }
        .modal-content { background: white; padding: 35px; border-radius: 20px; text-align: center; width: 85%; max-width: 380px; }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <div id="lobby">
            <h1 style="margin-bottom:20px;">ランドルト環五目並べ</h1>
            <div class="lobby-ui">
                <input type="text" id="roomName" placeholder="ルーム名を入力">
                <select id="timeLimit">
                    <option value="10">制限時間：10秒</option>
                    <option value="20">制限時間：20秒</option>
                    <option value="30" selected>制限時間：30秒</option>
                    <option value="free">制限なし</option>
                </select>
                <button class="btn" style="width:100%; margin-top:10px;" onclick="createRoom()">新規作成</button>
                <button class="btn" style="width:100%; margin-top:10px; background:#10b981;" onclick="joinRoom()">参加する</button>
                <p id="errorMsg" style="color:#ef4444; margin-top:15px; font-size:14px; font-weight:bold;"></p>
            </div>
        </div>

        <div id="gameArea">
            <div class="header">
                <div>
                    <strong id="roomTitle" style="font-size:18px;">ルーム</strong>
                    <div id="playerStatus">相手を待っています...</div>
                </div>
                <div id="timerDisplay">--</div>
            </div>

            <div id="canvasContainer">
                <div class="info-overlay">
                    <span id="coordDisplay">座標: (0, 0)</span> | <span id="zoomDisplay">100%</span>
                </div>
                <canvas id="gameCanvas"></canvas>
            </div>

            <div class="controls-bottom">
                <div class="direction-row" id="dirBtnGroup"></div>
                <div style="display:flex; justify-content: space-between; align-items: center;">
                    <div id="pairStatus" style="font-size:12px; color:#4b5563;">連続対: 黒0/3 白0/3</div>
                    <button class="btn" style="padding:6px 15px; background:#6b7280; font-size:14px;" onclick="location.reload()">退出</button>
                </div>

                <div id="reviewUI" class="hidden">
                    <button class="btn" onclick="reviewMove(-1)" style="background:#4b5563">◀ 前の手</button>
                    <span id="reviewStep" style="margin: 0 15px; font-weight:bold;">0 / 0</span>
                    <button class="btn" onclick="reviewMove(1)" style="background:#4b5563">次の手 ▶</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="winModal">
        <div class="modal-content">
            <h1 id="winMsg" style="font-size:32px; margin-bottom:10px;"></h1>
            <p id="winSub" style="font-size:18px; color:#4b5563; margin-bottom:25px;"></p>
            <button class="btn" style="width:100%; margin-bottom:10px;" onclick="startReview()">感想戦を開始</button>
            <button class="btn" style="width:100%; background:#9ca3af;" onclick="location.reload()">終了</button>
        </div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 設定：盤面サイズを128x128に
        const GRID_SIZE = 128;
        const CELL_BASE_SIZE = 40;

        let myRoom = "", myIndex = null, pieces = [], history = [];
        let currentPlayer = 0, consecutivePairs = [0, 0];
        // 初期位置を128マスの中心付近に
        let viewportX = GRID_SIZE / 2 - 5, viewportY = GRID_SIZE / 2 - 5, zoom = 1.0;
        let selectedDir = 0, isReview = false, reviewIndex = 0;
        let isMoving = false, lastTouchX = 0, lastTouchY = 0, initialDist = 0;

        function resize() {
            const container = document.getElementById('canvasContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        window.addEventListener('resize', resize);

        // --- 通信 ---
        function createRoom() {
            const name = document.getElementById('roomName').value;
            const time = document.getElementById('timeLimit').value;
            if(!name) return alert("ルーム名を入力してください");
            socket.emit('createRoom', { roomId: name, settings: { timeLimit: time } });
        }

        function joinRoom() {
            const name = document.getElementById('roomName').value;
            if(!name) return alert("ルーム名を入力してください");
            socket.emit('joinRoom', name);
        }

        socket.on('error_msg', m => document.getElementById('errorMsg').textContent = m);

        socket.on('roomJoined', data => {
            myRoom = data.roomId; myIndex = data.playerIndex;
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('gameArea').style.display = 'flex';
            document.getElementById('roomTitle').textContent = `ルーム: ${myRoom}`;
            initDirectionButtons();
            resize();
        });

        socket.on('gameStart', () => { updateUI(); draw(); });

        socket.on('moveMade', data => {
            const p = data.piece;
            pieces.push(p);
            history.push({...p});
            currentPlayer = data.nextTurn;
            consecutivePairs = data.consecutivePairs;

            // ★ 相手が置いた場合、その場所を中央に移動しズームを100%にする
            if (p.player !== myIndex) {
                focusOn(p.x, p.y);
            }

            updateUI();
            draw();
            checkDraw(); // 引き分けチェック
        });

        socket.on('timerUpdate', t => document.getElementById('timerDisplay').textContent = t + "s");

        socket.on('gameOver', data => {
            if(data.winner === -1) {
                document.getElementById('winMsg').textContent = "引き分け";
                document.getElementById('winSub').textContent = "盤面がすべて埋まりました。";
            } else {
                document.getElementById('winMsg').textContent = (data.winner === myIndex) ? "勝利！" : "敗北...";
                document.getElementById('winSub').textContent = data.reason === "timeout" ? "制限時間切れ" : "五目並び達成！";
            }
            document.getElementById('winModal').classList.add('active');
        });

        socket.on('playerLeft', () => { alert("相手が退出しました"); location.reload(); });

        // ★ 指定座標を画面中央に持ってくる関数
        function focusOn(gx, gy) {
            zoom = 1.0; // 拡大率を100%に
            document.getElementById('zoomDisplay').textContent = "100%";
            // viewportX/Y は画面左上の座標なので、中心にするには画面の半分引く
            const cellsInViewX = canvas.width / (CELL_BASE_SIZE * zoom);
            const cellsInViewY = canvas.height / (CELL_BASE_SIZE * zoom);
            viewportX = gx - cellsInViewX / 2 + 0.5;
            viewportY = gy - cellsInViewY / 2 + 0.5;
        }

        // --- 描画 ---
        function initDirectionButtons() {
            const container = document.getElementById('dirBtnGroup');
            ['↑', '→', '↓', '←'].forEach((l, i) => {
                const b = document.createElement('button');
                b.className = `dir-btn ${i===0?'active':''}`;
                b.textContent = l;
                b.onclick = () => {
                    selectedDir = i;
                    document.querySelectorAll('.dir-btn').forEach((btn,idx)=>btn.classList.toggle('active', idx===i));
                };
                container.appendChild(b);
            });
        }

        function updateUI() {
            const turn = (currentPlayer === myIndex) ? "★自分の番" : "相手の番";
            document.getElementById('playerStatus').textContent = `${turn} (${currentPlayer===0?'黒':'白'})`;
            document.getElementById('pairStatus').textContent = `連続対: 黒${consecutivePairs[0]}/3 白${consecutivePairs[1]}/3`;
        }

        function draw() {
            if(!canvas.width) return;
            const size = CELL_BASE_SIZE * zoom;
            ctx.fillStyle = '#1e3a0d'; // 枠外の色
            ctx.fillRect(0,0,canvas.width, canvas.height);

            // 盤面エリア（128x128）の背景
            const boardLeft = (0 - viewportX) * size;
            const boardTop = (0 - viewportY) * size;
            const boardWidth = GRID_SIZE * size;
            const boardHeight = GRID_SIZE * size;
            ctx.fillStyle = '#2d5016'; // 盤面の色
            ctx.fillRect(boardLeft, boardTop, boardWidth, boardHeight);
            
            // グリッド線（盤面内のみ）
            ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
            for(let i = 0; i <= GRID_SIZE; i++) {
                // 縦線
                let vx = (i - viewportX) * size;
                if(vx >= 0 && vx <= canvas.width) {
                    ctx.beginPath(); ctx.moveTo(vx, Math.max(0, boardTop)); ctx.lineTo(vx, Math.min(canvas.height, boardTop + boardHeight)); ctx.stroke();
                }
                // 横線
                let vy = (i - viewportY) * size;
                if(vy >= 0 && vy <= canvas.height) {
                    ctx.beginPath(); ctx.moveTo(Math.max(0, boardLeft), vy); ctx.lineTo(Math.min(canvas.width, boardLeft + boardWidth), vy); ctx.stroke();
                }
            }

            const currentSet = isReview ? history.slice(0, reviewIndex) : pieces;
            currentSet.forEach(p => {
                const x = (p.x - viewportX) * size + size/2;
                const y = (p.y - viewportY) * size + size/2;
                if(x < -size || x > canvas.width+size || y < -size || y > canvas.height+size) return;

                ctx.strokeStyle = (p.player === 0) ? '#111' : '#eee';
                ctx.lineWidth = 3.5 * zoom;
                ctx.beginPath(); ctx.arc(x, y, 12*zoom, 0, Math.PI*2); ctx.stroke();
                
                ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 4.5 * zoom;
                ctx.beginPath();
                const angles = [-Math.PI/2, 0, Math.PI/2, Math.PI];
                ctx.arc(x, y, 12*zoom, angles[p.direction]-0.4, angles[p.direction]+0.4);
                ctx.stroke();
            });

            // 対のハイライト
            currentSet.forEach((p, i) => {
                for(let j=i+1; j<currentSet.length; j++) {
                    const op = currentSet[j];
                    if(p.player === op.player && isFacing(p, op)) {
                        ctx.strokeStyle = 'rgba(239, 68, 68, 0.7)'; ctx.setLineDash([5, 5]);
                        ctx.beginPath(); ctx.moveTo((p.x-viewportX)*size+size/2, (p.y-viewportY)*size+size/2);
                        ctx.lineTo((op.x-viewportX)*size+size/2, (op.y-viewportY)*size+size/2);
                        ctx.stroke(); ctx.setLineDash([]);
                    }
                }
            });
        }

        function isFacing(p1, p2) {
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) return false;
            if (dx === 0 && dy === 1) return p1.direction === 2 && p2.direction === 0;
            if (dx === 0 && dy === -1) return p1.direction === 0 && p2.direction === 2;
            if (dx === 1 && dy === 0) return p1.direction === 1 && p2.direction === 3;
            if (dx === -1 && dy === 0) return p1.direction === 3 && p2.direction === 1;
            return false;
        }

        // --- 操作 ---
        const handleDown = (x, y) => { isMoving = false; lastTouchX = x; lastTouchY = y; };
        const handleMove = (x, y) => {
            isMoving = true;
            viewportX -= (x - lastTouchX) / (CELL_BASE_SIZE * zoom);
            viewportY -= (y - lastTouchY) / (CELL_BASE_SIZE * zoom);
            lastTouchX = x; lastTouchY = y;
            draw();
        };

        canvas.addEventListener('mousedown', e => { if(e.button !== 0) handleDown(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => {
            const r = canvas.getBoundingClientRect();
            const gx = Math.floor(viewportX + (e.clientX-r.left)/(CELL_BASE_SIZE*zoom)), gy = Math.floor(viewportY + (e.clientY-r.top)/(CELL_BASE_SIZE*zoom));
            document.getElementById('coordDisplay').textContent = `座標: (${gx}, ${gy})`;
            if(e.buttons === 2 || e.buttons === 4) handleMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', e => {
            if(e.touches.length === 1) handleDown(e.touches[0].clientX, e.touches[0].clientY);
            else if(e.touches.length === 2) initialDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        }, {passive: false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length === 1) handleMove(e.touches[0].clientX, e.touches[0].clientY);
            else if(e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                if(initialDist > 0) {
                    zoom = Math.max(0.5, Math.min(3, zoom * (dist / initialDist)));
                    initialDist = dist;
                    document.getElementById('zoomDisplay').textContent = Math.round(zoom*100) + "%";
                    draw();
                }
            }
        }, {passive: false});

        canvas.addEventListener('touchend', e => {
            if(!isMoving && e.changedTouches.length === 1 && currentPlayer === myIndex && !isReview) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.changedTouches[0];
                const gx = Math.floor(viewportX + (touch.clientX - rect.left) / (CELL_BASE_SIZE * zoom));
                const gy = Math.floor(viewportY + (touch.clientY - rect.top) / (CELL_BASE_SIZE * zoom));
                attemptPlace(gx, gy);
            }
            initialDist = 0;
        });

        canvas.addEventListener('click', e => {
            if(e.button === 0 && !isReview && currentPlayer === myIndex) {
                const rect = canvas.getBoundingClientRect();
                const gx = Math.floor(viewportX + (e.clientX - rect.left) / (CELL_BASE_SIZE * zoom));
                const gy = Math.floor(viewportY + (e.clientY - rect.top) / (CELL_BASE_SIZE * zoom));
                attemptPlace(gx, gy);
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom = Math.max(0.5, Math.min(3, zoom + (e.deltaY < 0 ? 0.1 : -0.1)));
            document.getElementById('zoomDisplay').textContent = Math.round(zoom*100) + "%";
            draw();
        }, {passive: false});

        function attemptPlace(gx, gy) {
            // 盤面外チェック
            if(gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return;
            if(pieces.find(p => p.x === gx && p.y === gy)) return;

            let isPair = false;
            const lastOpp = pieces.filter(p => p.player !== myIndex).pop();
            if(lastOpp) {
                const dx = gx - lastOpp.x, dy = gy - lastOpp.y;
                if((lastOpp.direction===0 && dx===0 && dy===-1) || (lastOpp.direction===1 && dx===1 && dy===0) ||
                   (lastOpp.direction===2 && dx===0 && dy===1) || (lastOpp.direction===3 && dx===-1 && dy===0)) isPair = true;
            }
            if(isPair && consecutivePairs[myIndex] >= 3) return alert("4回連続対は禁止です！");

            const piece = { x: gx, y: gy, direction: selectedDir, player: myIndex };
            const nextPairs = [...consecutivePairs];
            nextPairs[myIndex] = isPair ? nextPairs[myIndex] + 1 : 0;

            socket.emit('placePiece', { roomId: myRoom, piece, consecutivePairs: nextPairs });
            if(checkWin(pieces.concat(piece), myIndex)) socket.emit('declareWin', { roomId: myRoom, winner: myIndex });
        }

        function checkWin(pList, pIdx) {
            const myP = pList.filter(p => p.player === pIdx);
            const dList = [[1,0],[0,1],[1,1],[1,-1]];
            for(let p of myP) {
                for(let [dx, dy] of dList) {
                    let line = [p];
                    for(let i=1; i<5; i++) {
                        const t = myP.find(v => v.x === p.x+dx*i && v.y === p.y+dy*i);
                        if(t) line.push(t); else break;
                    }
                    if(line.length >= 5) {
                        for(let lp of line) for(let op of myP) if(lp !== op && isFacing(lp, op)) return true;
                    }
                }
            }
            return false;
        }

        // 引き分けチェック
        function checkDraw() {
            if(pieces.length >= GRID_SIZE * GRID_SIZE) {
                socket.emit('declareWin', { roomId: myRoom, winner: -1 }); // winner: -1 を引き分けとする
            }
        }

        // --- 感想戦 ---
        function startReview() {
            document.getElementById('winModal').classList.remove('active');
            isReview = true; reviewIndex = history.length;
            document.getElementById('reviewUI').classList.remove('hidden');
            updateReviewUI(); draw();
        }
        function reviewMove(dir) {
            reviewIndex = Math.max(0, Math.min(history.length, reviewIndex + dir));
            updateReviewUI(); draw();
            // 感想戦でも移動後の駒にフォーカス
            if(reviewIndex > 0) {
                const p = history[reviewIndex - 1];
                focusOn(p.x, p.y);
            }
        }
        function updateReviewUI() {
            document.getElementById('reviewStep').textContent = `${reviewIndex} / ${history.length}`;
        }
    </script>
</body>
</html>

