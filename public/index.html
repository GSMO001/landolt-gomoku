<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LANDOLT GOMOKU ONLINE PRO</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        :root { --primary: #2563eb; --success: #16a34a; --danger: #dc2626; --bg: #0f172a; --panel: #ffffff; }
        * { margin:0; padding:0; box-sizing:border-box; -webkit-touch-callout:none; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); height: 100vh; overflow: hidden; display: flex; justify-content: center; }

        .container { width: 100%; max-width: 550px; height: 100%; background: var(--panel); display: flex; flex-direction: column; position: relative; }

        /* „É≠„Éì„ÉºÔºö„Çπ„ÇØ„É≠„Éº„É´ÂèØËÉΩ„Ç®„É™„Ç¢„ÅÆÂÆöÁæ© */
        #lobby { flex: 1; display: flex; flex-direction: column; padding: 20px; overflow: hidden; }
        .header-title { font-size: 26px; font-weight: 800; color: #1e293b; margin-bottom: 20px; text-align: center; }
        
        .create-box { background: #f1f5f9; padding: 15px; border-radius: 12px; margin-bottom: 15px; }
        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; font-size: 12px; font-weight: bold; color: #64748b; margin-bottom: 4px; }
        input, select { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #cbd5e1; font-size: 16px; outline: none; }

        .search-bar { margin-bottom: 10px; }
        
        .room-list-wrapper { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; border: 1px solid #e2e8f0; border-radius: 12px; padding: 10px; background: #fff; }
        .room-item { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .room-item:last-child { margin-bottom: 0; }
        .room-item b { font-size: 16px; color: #334155; }
        .room-item p { font-size: 12px; color: #94a3b8; }

        /* „Ç≤„Éº„É†ÁîªÈù¢ */
        #game { display: none; flex-direction: column; height: 100%; touch-action: none; }
        .game-header { padding: 15px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; }
        #canvas-area { flex: 1; background: #064e3b; position: relative; overflow: hidden; cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; }

        .game-footer { padding: 20px; padding-bottom: 45px; border-top: 1px solid #e2e8f0; background: #fff; }
        .direction-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; }
        .dir-btn { height: 55px; border: 2px solid #e2e8f0; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: 0.2s; }
        .dir-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        
        .leave-btn { width: 100%; padding: 15px; font-size: 24px; font-weight: 800; color: var(--danger); background: none; border: none; cursor: pointer; }

        /* Ê±éÁî®„Éú„Çø„É≥ */
        .btn-main { background: var(--primary); color: white; padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; width: 100%; }
        .btn-join { background: var(--success); color: white; border: none; padding: 8px 16px; border-radius: 6px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <div id="lobby">
        <h1 class="header-title">LANDOLT ONLINE</h1>
        
        <div class="create-box">
            <div class="input-group">
                <label>ROOM NAME</label>
                <input type="text" id="roomId" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ">
            </div>
            <div class="input-group">
                <label>PASSWORD (Optional)</label>
                <input type="password" id="roomPw" placeholder="Á©∫Ê¨Ñ„Åß„Éë„Çπ„ÉØ„Éº„Éâ„Å™„Åó">
            </div>
            <button class="btn-main" onclick="createRoom()">Êñ∞Ë¶èÂØæÂ±Ä„Çí‰ΩúÊàê</button>
        </div>

        <div class="search-bar">
            <input type="text" id="search" placeholder="üîç „É´„Éº„É†„ÇíÊ§úÁ¥¢..." oninput="updateListView()">
        </div>

        <div class="room-list-wrapper" id="list-target">
            </div>
    </div>

    <div id="game">
        <div class="game-header">
            <div>
                <b id="display-room">---</b><br>
                <small id="status-text" style="color: #64748b; font-weight: bold;">WAITING...</small>
            </div>
            <div id="pair-stats" style="font-weight: 800; color: #1e293b;">PAIRS: 0 / 0</div>
        </div>
        
        <div id="canvas-area"><canvas id="stage"></canvas></div>

        <div class="game-footer">
            <div class="direction-grid">
                <div class="dir-btn active" id="db0" onclick="changeDir(0)">‚Üë</div>
                <div class="dir-btn" id="db1" onclick="changeDir(1)">‚Üí</div>
                <div class="dir-btn" id="db2" onclick="changeDir(2)">‚Üì</div>
                <div class="dir-btn" id="db3" onclick="changeDir(3)">‚Üê</div>
            </div>
            <button class="leave-btn" onclick="exitGame()">LEAVE GAME</button>
        </div>
    </div>
</div>

<script>
    const socket = io();
    const cvs = document.getElementById('stage');
    const ctx = cvs.getContext('2d', { alpha: false });
    const area = document.getElementById('canvas-area');
    
    let g_rooms = [], g_side = null, g_turn = 0, g_board = [], g_pairs = [0, 0], g_active = false;
    let camera = { x: 64, y: 64, zoom: 1.0 }, selectedDir = 0;
    let touchData = { isDrag: false, lastX: 0, lastY: 0, lastDist: 0 };

    // --- Lobby Functions ---
    socket.on('updateRoomList', data => { g_rooms = data; updateListView(); });
    
    function updateListView() {
        const target = document.getElementById('list-target');
        const q = document.getElementById('search').value.toLowerCase();
        target.innerHTML = "";
        
        const filtered = g_rooms.filter(r => r.id.toLowerCase().includes(q));
        if (filtered.length === 0) {
            target.innerHTML = `<p style="text-align:center; padding:20px; color:#94a3b8;">Ë°®Á§∫„Åß„Åç„Çã„É´„Éº„É†„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>`;
            return;
        }

        filtered.forEach(r => {
            const div = document.createElement('div');
            div.className = 'room-item';
            div.innerHTML = `
                <div><b>${r.id} ${r.hasPw?'üîí':''}</b><p>${r.status} (${r.playerCount}/2)</p></div>
                <button class="btn-join" onclick="joinRoom('${r.id}', ${r.hasPw})" ${r.playerCount>=2?'disabled':''}>ÂèÇÂä†</button>
            `;
            target.appendChild(div);
        });
    }

    function createRoom() {
        const id = document.getElementById('roomId').value;
        const pw = document.getElementById('roomPw').value;
        if (!id) return alert("„É´„Éº„É†Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
        socket.emit('createRoom', { roomId: id, password: pw, settings: { timeLimit: 60 } });
    }

    function joinRoom(id, hasPw) {
        const pw = hasPw ? prompt("„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ") : "";
        if (pw !== null) socket.emit('joinRoom', { roomId: id, password: pw });
    }

    // --- Game Engine ---
    socket.on('roomJoined', d => {
        g_side = d.playerIndex;
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game').style.display = 'flex';
        document.getElementById('display-room').textContent = d.roomId;
        initCanvas();
    });

    socket.on('gameStart', () => { g_active = true; syncUI(); draw(); });
    
    socket.on('moveMade', d => {
        g_board.push(d.piece);
        g_turn = d.nextTurn;
        g_pairs = d.consecutivePairs;
        syncUI();
        draw();
    });

    socket.on('gameOver', d => {
        g_active = false;
        alert(d.winner === g_side ? "ÂãùÂà©„Åó„Åæ„Åó„ÅüÔºÅ" : "ÊïóÂåó„Åó„Åæ„Åó„Åü...");
        location.reload();
    });

    socket.on('playerLeft', () => { alert("ÂØæÊà¶Áõ∏Êâã„ÅåÈÄÄÂá∫„Åó„Åæ„Åó„Åü"); location.reload(); });
    socket.on('error_msg', m => alert(m));

    function initCanvas() {
        cvs.width = area.clientWidth;
        cvs.height = area.clientHeight;
        window.addEventListener('resize', () => {
            cvs.width = area.clientWidth;
            cvs.height = area.clientHeight;
            draw();
        });
        draw();
    }

    function draw() {
        if (!cvs.width) return;
        ctx.fillStyle = "#020617"; ctx.fillRect(0, 0, cvs.width, cvs.height);
        
        const cellSize = 45 * camera.zoom;
        const offsetX = cvs.width/2 - camera.x * cellSize;
        const offsetY = cvs.height/2 - camera.y * cellSize;

        // Áõ§Èù¢ËÉåÊôØ
        ctx.fillStyle = "#064e3b";
        ctx.fillRect(offsetX, offsetY, 128 * cellSize, 128 * cellSize);

        // „Ç∞„É™„ÉÉ„Éâ
        ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= 128; i++) {
            ctx.moveTo(offsetX + i * cellSize, offsetY);
            ctx.lineTo(offsetX + i * cellSize, offsetY + 128 * cellSize);
            ctx.moveTo(offsetX, offsetY + i * cellSize);
            ctx.lineTo(offsetX + 128 * cellSize, offsetY + i * cellSize);
        }
        ctx.stroke();

        // Èßí
        g_board.forEach(p => {
            const centerX = offsetX + p.x * cellSize + cellSize/2;
            const centerY = offsetY + p.y * cellSize + cellSize/2;
            const radius = cellSize * 0.35;

            // Êú¨‰Ωì
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = p.player === 0 ? "#000" : "#fff";
            ctx.lineWidth = cellSize * 0.1;
            ctx.stroke();

            // ÈñãÂè£ÈÉ®Ôºà„É©„É≥„Éâ„É´„ÉàÁí∞Ôºâ
            ctx.beginPath();
            const angle = [-Math.PI/2, 0, Math.PI/2, Math.PI][p.direction];
            ctx.arc(centerX, centerY, radius, angle - 0.4, angle + 0.4);
            ctx.strokeStyle = "#fbbf24"; // ÈáëËâ≤„ÅßÂº∑Ë™ø
            ctx.lineWidth = cellSize * 0.12;
            ctx.stroke();
        });
    }

    // --- Interaction ---
    area.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
            touchData.isDrag = false;
            touchData.lastX = e.touches[0].clientX;
            touchData.lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            touchData.lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        }
    }, { passive: false });

    area.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const dx = e.touches[0].clientX - touchData.lastX;
            const dy = e.touches[0].clientY - touchData.lastY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) touchData.isDrag = true;
            camera.x -= dx / (45 * camera.zoom);
            camera.y -= dy / (45 * camera.zoom);
            touchData.lastX = e.touches[0].clientX;
            touchData.lastY = e.touches[0].clientY;
            draw();
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const factor = dist / touchData.lastDist;
            camera.zoom = Math.min(Math.max(camera.zoom * factor, 0.4), 3.0);
            touchData.lastDist = dist;
            draw();
        }
    }, { passive: false });

    area.addEventListener('touchend', e => {
        if (!touchData.isDrag && e.changedTouches.length === 1) {
            const rect = cvs.getBoundingClientRect();
            const touchX = e.changedTouches[0].clientX - rect.left;
            const touchY = e.changedTouches[0].clientY - rect.top;
            handleBoardClick(touchX, touchY);
        }
    });

    function handleBoardClick(sx, sy) {
        if (!g_active || g_turn !== g_side) return;
        
        const cellSize = 45 * camera.zoom;
        const gx = Math.floor((sx - (cvs.width/2 - camera.x * cellSize)) / cellSize);
        const gy = Math.floor((sy - (cvs.height/2 - camera.y * cellSize)) / cellSize);

        if (gx < 0 || gx >= 128 || gy < 0 || gy >= 128) return;
        if (g_board.some(p => p.x === gx && p.y === gy)) return;

        // ÂØæ„ÅÆÂà§ÂÆö
        let isPairMove = false;
        const lastOppMove = g_board.filter(p => p.player !== g_side).pop();
        if (lastOppMove) {
            const dx = gx - lastOppMove.x;
            const dy = gy - lastOppMove.y;
            // Áõ∏Êâã„ÅÆÈñãÂè£ÈÉ®„Å®Ëá™ÂàÜ„ÅÆÂ∫ßÊ®ô„Åå‰∏ÄËá¥„Åô„Çã„Åã
            if (lastOppMove.direction === 0 && dy === -1 && dx === 0) isPairMove = true;
            if (lastOppMove.direction === 1 && dx === 1 && dy === 0) isPairMove = true;
            if (lastOppMove.direction === 2 && dy === 1 && dx === 0) isPairMove = true;
            if (lastOppMove.direction === 3 && dx === -1 && dy === 0) isPairMove = true;
        }

        if (isPairMove && g_pairs[g_side] >= 3) return alert("ÂØæ„ÅØ3ÂõûÈÄ£Á∂ö„Åæ„Åß„Åß„ÅôÔºÅ");

        const newPairCounts = [...g_pairs];
        newPairCounts[g_side] = isPairMove ? newPairCounts[g_side] + 1 : 0;

        const piece = { x: gx, y: gy, direction: selectedDir, player: g_side };
        socket.emit('placePiece', {
            roomId: document.getElementById('display-room').textContent,
            piece: piece,
            consecutivePairs: newPairCounts
        });

        if (checkVictory(g_board.concat(piece), g_side)) {
            socket.emit('declareWin', { roomId: document.getElementById('display-room').textContent, winner: g_side });
        }
    }

    function checkVictory(board, side) {
        const mine = board.filter(p => p.player === side);
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

        for (const p of mine) {
            for (const [vx, vy] of directions) {
                let chain = [p];
                for (let i = 1; i < 5; i++) {
                    const found = mine.find(m => m.x === p.x + vx * i && m.y === p.y + vy * i);
                    if (found) chain.push(found); else break;
                }
                if (chain.length >= 5) {
                    // ‰∫îÁõÆ„ÅÆ„Å™„Åã„Å´„ÄåÂØæ„Äç„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã
                    const hasPair = chain.some(c => board.some(other => other !== c && isPairRelation(c, other)));
                    if (hasPair) return true;
                }
            }
        }
        return false;
    }

    function isPairRelation(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        if (dx === 0 && dy === -1) return a.direction === 0 && b.direction === 2;
        if (dx === 1 && dy === 0) return a.direction === 1 && b.direction === 3;
        if (dx === 0 && dy === 1) return a.direction === 2 && b.direction === 0;
        if (dx === -1 && dy === 0) return a.direction === 3 && b.direction === 1;
        return false;
    }

    function syncUI() {
        const status = document.getElementById('status-text');
        status.textContent = g_turn === g_side ? "‚òÖ „ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥" : "Áõ∏Êâã„ÅåËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...";
        status.style.color = g_turn === g_side ? "var(--primary)" : "#64748b";
        document.getElementById('pair-stats').textContent = `PAIRS: ${g_pairs[0]} / ${g_pairs[1]}`;
    }

    function changeDir(d) {
        selectedDir = d;
        document.querySelectorAll('.dir-btn').forEach((b, i) => b.classList.toggle('active', i === d));
    }

    function exitGame() { if (confirm("ÂØæÂ±Ä„ÇíÁµÇ‰∫Ü„Åó„Å¶„É≠„Éì„Éº„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü")) location.reload(); }
</script>
</body>
</html>

