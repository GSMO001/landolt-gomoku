<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°äº”ç›®ä¸¦ã¹ ONLINE</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #f0f2f5; display: flex; justify-content: center; min-height: 100vh; overflow: hidden; }
        .container { background: white; width: 100vw; height: 100vh; position: relative; display: flex; flex-direction: column; }

        /* ãƒ­ãƒ“ãƒ¼ */
        #lobby { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .create-panel { background: #fff; width: 100%; max-width: 400px; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .room-list { width: 100%; max-width: 400px; }
        .room-item { background: white; border: 1px solid #ddd; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .room-item:hover { background: #f9f9f9; }
        
        input, select { width: 100%; padding: 12px; margin: 8px 0; border: 1px solid #ccc; border-radius: 6px; font-size: 16px; }
        .btn { padding: 12px 20px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }

        /* ã‚²ãƒ¼ãƒ  */
        #gameArea { display: none; flex: 1; flex-direction: column; }
        .header { padding: 10px 20px; background: white; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; }
        #canvasContainer { flex: 1; position: relative; background: #1e3a0d; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        
        .controls { padding: 15px; background: white; border-top: 1px solid #ddd; }
        .dir-btn { width: 50px; height: 50px; border: 2px solid #ccc; background: white; border-radius: 10px; font-size: 20px; margin: 0 4px; font-weight: bold; }
        .dir-btn.active { border-color: #3b82f6; background: #dbeafe; }
        
        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center; }
        .modal.active { display: flex; }
        .modal-content { background: white; padding: 30px; border-radius: 15px; text-align: center; width: 90%; max-width: 400px; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <div id="lobby">
            <h2 style="margin: 20px 0;">ãƒ©ãƒ³ãƒ‰ãƒ«ãƒˆç’°äº”ç›®ä¸¦ã¹</h2>
            
            <div class="create-panel">
                <h4>ãƒ«ãƒ¼ãƒ ã‚’æ–°è¦ä½œæˆ</h4>
                <input type="text" id="newRoomId" placeholder="ãƒ«ãƒ¼ãƒ å">
                <input type="password" id="newRoomPass" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆä»»æ„ï¼‰">
                <select id="timeSelect">
                    <option value="10">10ç§’</option>
                    <option value="30" selected>30ç§’</option>
                    <option value="free">ç„¡åˆ¶é™</option>
                </select>
                <button class="btn" style="width:100%" onclick="handleCreate()">ä½œæˆã—ã¦å…¥å®¤</button>
            </div>

            <div class="room-list">
                <h4>é€²è¡Œä¸­ã®ãƒ«ãƒ¼ãƒ </h4>
                <div id="listBody" style="margin-top:10px;"></div>
            </div>
        </div>

        <div id="gameArea">
            <div class="header">
                <div><b id="roomNameLabel">ãƒ«ãƒ¼ãƒ </b><br><small id="statusLabel">å¾…æ©Ÿä¸­...</small></div>
                <div id="timerDisplay" style="font-size:24px; font-weight:bold; color:#e11d48;">--</div>
            </div>
            <div id="canvasContainer">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div class="controls">
                <div style="display:flex; justify-content:center; margin-bottom:12px;" id="dirBtnGroup"></div>
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span id="pairLabel" style="font-size:12px; color:#666;">é€£ç¶šå¯¾: 0/3</span>
                    <button class="btn" style="background:#64748b; padding:8px 16px;" onclick="location.reload()">é€€å‡º</button>
                </div>

                <div id="reviewControls" class="hidden" style="margin-top:10px; border-top:1px solid #eee; padding-top:10px; text-align:center;">
                    <button class="btn" onclick="changeReview(-1)">â—€ å‰ã®æ‰‹</button>
                    <span id="reviewStepLabel" style="margin:0 15px; font-weight:bold;">0 / 0</span>
                    <button class="btn" onclick="changeReview(1)">æ¬¡ã®æ‰‹ â–¶</button>
                </div>
            </div>
        </div>
    </div>

    <div id="mainModal" class="modal">
        <div id="modalBody" class="modal-content"></div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 128;

        let myRoom = "", myIndex = null, pieces = [], history = [];
        let currentPlayer = 0, consecutivePairs = [0, 0];
        let viewportX = 64-5, viewportY = 64-5, zoom = 1.0;
        let selectedDir = 0, isReview = false, reviewIndex = 0;
        let gameActive = false;

        // --- ãƒ«ãƒ¼ãƒ ãƒªã‚¹ãƒˆç®¡ç† ---
        socket.on('roomList', list => {
            const body = document.getElementById('listBody');
            body.innerHTML = list.length ? "" : "<p style='color:#999; text-align:center;'>ç¾åœ¨ãƒ«ãƒ¼ãƒ ã¯ã‚ã‚Šã¾ã›ã‚“</p>";
            list.forEach(r => {
                const div = document.createElement('div');
                div.className = "room-item";
                div.innerHTML = `<div><b>${r.id}</b><br><small>${r.status} (${r.playerCount}/2) ${r.hasPass?'ğŸ”’':''}</small></div>
                                 <button class="btn" style="padding:6px 12px; font-size:14px;" ${r.playerCount>=2?'disabled':''}>å‚åŠ </button>`;
                div.onclick = () => r.playerCount < 2 && handleJoin(r.id, r.hasPass);
                body.appendChild(div);
            });
        });

        function handleCreate() {
            const roomId = document.getElementById('newRoomId').value;
            const password = document.getElementById('newRoomPass').value;
            if(!roomId) return alert("ãƒ«ãƒ¼ãƒ åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            socket.emit('createRoom', { roomId, password, settings: { timeLimit: document.getElementById('timeSelect').value } });
        }

        function handleJoin(roomId, hasPass) {
            let password = "";
            if(hasPass) {
                password = prompt("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
                if(password === null) return;
            }
            socket.emit('joinRoom', { roomId, password });
        }

        socket.on('error_msg', m => alert(m));
        
        socket.on('roomJoined', data => {
            myRoom = data.roomId; myIndex = data.playerIndex;
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameArea').style.display = 'flex';
            document.getElementById('roomNameLabel').textContent = `ãƒ«ãƒ¼ãƒ : ${myRoom}`;
            initDirectionButtons();
            resize();
        });

        // --- ã‚²ãƒ¼ãƒ é€²è¡Œ ---
        socket.on('gameStart', () => {
            gameActive = true;
            updateStatus();
            draw();
        });

        socket.on('moveMade', data => {
            pieces.push(data.piece);
            history.push({...data.piece});
            currentPlayer = data.nextTurn;
            consecutivePairs = data.consecutivePairs;
            
            // ç›¸æ‰‹ãŒç½®ã„ãŸãªã‚‰ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
            if(data.piece.player !== myIndex) {
                focusOn(data.piece.x, data.piece.y);
            }
            updateStatus();
            draw();
        });

        socket.on('timerUpdate', t => document.getElementById('timerDisplay').textContent = t + "s");

        socket.on('gameOver', data => {
            gameActive = false;
            const isWin = data.winner === myIndex;
            const title = data.winner === -1 ? "å¼•ãåˆ†ã‘" : (isWin ? "å‹åˆ©ï¼" : "æ•—åŒ—...");
            const reason = data.reason === 'timeout' ? "æ™‚é–“åˆ‡ã‚Œã§ã™" : "äº”ç›®ä¸¦ã³ãŒå®Œæˆã—ã¾ã—ãŸ";
            
            showModal(`<h2>${title}</h2><p style='margin:10px 0;'>${reason}</p>
                       <button class="btn" style="width:100%; margin-top:15px;" onclick="startReviewMode()">æ„Ÿæƒ³æˆ¦ã‚’é–‹å§‹</button>
                       <button class="btn" style="width:100%; margin-top:10px; background:#94a3b8;" onclick="location.reload()">ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹</button>`);
        });

        socket.on('playerLeft', () => {
            alert("å¯¾æˆ¦ç›¸æ‰‹ãŒé€€å‡ºã—ã¾ã—ãŸã€‚");
            location.reload();
        });

        // --- æ„Ÿæƒ³æˆ¦ãƒ­ã‚¸ãƒƒã‚¯ ---
        function startReviewMode() {
            hideModal();
            isReview = true;
            reviewIndex = history.length;
            document.getElementById('reviewControls').classList.remove('hidden');
            updateReviewUI();
            draw();
        }

        function changeReview(dir) {
            reviewIndex = Math.max(0, Math.min(history.length, reviewIndex + dir));
            if(reviewIndex > 0) {
                const p = history[reviewIndex - 1];
                focusOn(p.x, p.y);
            }
            updateReviewUI();
            draw();
        }

        function updateReviewUI() {
            document.getElementById('reviewStepLabel').textContent = `${reviewIndex} / ${history.length}`;
        }

        // --- æç”»ãƒ»æ“ä½œ ---
        function initDirectionButtons() {
            const group = document.getElementById('dirBtnGroup');
            group.innerHTML = "";
            ['â†‘', 'â†’', 'â†“', 'â†'].forEach((label, i) => {
                const b = document.createElement('button');
                b.className = `dir-btn ${i===0?'active':''}`;
                b.textContent = label;
                b.onclick = () => {
                    selectedDir = i;
                    document.querySelectorAll('.dir-btn').forEach((btn,idx) => btn.classList.toggle('active', idx===i));
                };
                group.appendChild(b);
            });
        }

        function updateStatus() {
            const color = (currentPlayer === 0) ? "é»’" : "ç™½";
            const status = !gameActive ? "ç›¸æ‰‹ã®å…¥å®¤ã‚’å¾…ã£ã¦ã„ã¾ã™..." : (currentPlayer === myIndex ? `â˜…è‡ªåˆ†ã®ç•ª (${color})` : `ç›¸æ‰‹ã®ç•ª (${color})`);
            document.getElementById('statusLabel').textContent = status;
            document.getElementById('pairLabel').textContent = `é€£ç¶šå¯¾: é»’${consecutivePairs[0]}/3 ç™½${consecutivePairs[1]}/3`;
        }

        function focusOn(gx, gy) {
            zoom = 1.0;
            const cw = canvas.width / (40 * zoom), ch = canvas.height / (40 * zoom);
            viewportX = gx - cw/2 + 0.5;
            viewportY = gy - ch/2 + 0.5;
        }

        function draw() {
            if(!canvas.width) return;
            const size = 40 * zoom;
            ctx.fillStyle = '#1e3a0d'; ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = '#2d5016';
            ctx.fillRect((0-viewportX)*size, (0-viewportY)*size, GRID_SIZE*size, GRID_SIZE*size);

            // æç”»ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®åˆ‡ã‚Šæ›¿ãˆ
            const list = isReview ? history.slice(0, reviewIndex) : pieces;

            list.forEach(p => {
                const x = (p.x - viewportX) * size + size/2;
                const y = (p.y - viewportY) * size + size/2;
                if(x < -size || x > canvas.width+size || y < -size || y > canvas.height+size) return;

                ctx.strokeStyle = p.player === 0 ? '#111' : '#eee';
                ctx.lineWidth = 3 * zoom;
                ctx.beginPath(); ctx.arc(x, y, 12*zoom, 0, Math.PI*2); ctx.stroke();
                
                ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 4 * zoom;
                ctx.beginPath();
                const angles = [-Math.PI/2, 0, Math.PI/2, Math.PI];
                ctx.arc(x, y, 12*zoom, angles[p.direction]-0.4, angles[p.direction]+0.4);
                ctx.stroke();
            });
        }

        function attemptPlace(gx, gy) {
            if(!gameActive || currentPlayer !== myIndex || isReview) return;
            if(gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return;
            if(pieces.find(p => p.x === gx && p.y === gy)) return;

            let isPair = false;
            const lastOpp = pieces.filter(p => p.player !== myIndex).pop();
            if(lastOpp) {
                const dx = gx - lastOpp.x, dy = gy - lastOpp.y;
                if((lastOpp.direction===0 && dx===0 && dy===-1) || (lastOpp.direction===1 && dx===1 && dy===0) ||
                   (lastOpp.direction===2 && dx===0 && dy===1) || (lastOpp.direction===3 && dx===-1 && dy===0)) isPair = true;
            }
            if(isPair && consecutivePairs[myIndex] >= 3) return alert("4å›é€£ç¶šã®ã€å¯¾ã€ã¯ç¦æ­¢ã§ã™");

            currentPlayer = -1; // é€šä¿¡ä¸­ãƒ­ãƒƒã‚¯
            const piece = { x: gx, y: gy, direction: selectedDir, player: myIndex };
            const nextPairs = [...consecutivePairs];
            nextPairs[myIndex] = isPair ? nextPairs[myIndex] + 1 : 0;

            socket.emit('placePiece', { roomId: myRoom, piece, consecutivePairs: nextPairs });
            if(checkWin(pieces.concat(piece), myIndex)) socket.emit('declareWin', { roomId: myRoom, winner: myIndex });
        }

        // å‹åˆ©åˆ¤å®š
        function checkWin(pList, pIdx) {
            const myP = pList.filter(p => p.player === pIdx);
            const dList = [[1,0],[0,1],[1,1],[1,-1]];
            for(let p of myP) {
                for(let [dx, dy] of dList) {
                    let line = [p];
                    for(let i=1; i<5; i++) {
                        const t = myP.find(v => v.x === p.x+dx*i && v.y === p.y+dy*i);
                        if(t) line.push(t); else break;
                    }
                    if(line.length >= 5) {
                        for(let lp of line) for(let op of myP) if(lp !== op && isFacing(lp, op)) return true;
                    }
                }
            }
            return false;
        }

        function isFacing(p1, p2) {
            const dx = p2.x-p1.x, dy = p2.y-p1.y;
            if(Math.abs(dx)>1 || Math.abs(dy)>1) return false;
            if(dx===0 && dy===1) return p1.direction===2 && p2.direction===0;
            if(dx===0 && dy===-1) return p1.direction===0 && p2.direction===2;
            if(dx===1 && dy===0) return p1.direction===1 && p2.direction===3;
            if(dx===-1 && dy===0) return p1.direction===3 && p2.direction===1;
            return false;
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
        function resize() {
            const c = document.getElementById('canvasContainer');
            canvas.width = c.clientWidth; canvas.height = c.clientHeight;
            draw();
        }
        window.onresize = resize;
        function showModal(h) { document.getElementById('modalBody').innerHTML = h; document.getElementById('mainModal').classList.add('active'); }
        function hideModal() { document.getElementById('mainModal').classList.remove('active'); }

        let isMoving = false, lastX, lastY, startDist;
        canvas.onmousedown = e => { if(e.button!==0) { isMoving=false; lastX=e.clientX; lastY=e.clientY; } };
        window.onmousemove = e => { if(e.buttons===2 || e.buttons===4) { isMoving=true; viewportX-=(e.clientX-lastX)/(40*zoom); viewportY-=(e.clientY-lastY)/(40*zoom); lastX=e.clientX; lastY=e.clientY; draw(); } };
        canvas.onclick = e => { if(!isMoving) { const r=canvas.getBoundingClientRect(); attemptPlace(Math.floor(viewportX+(e.clientX-r.left)/(40*zoom)), Math.floor(viewportY+(e.clientY-r.top)/(40*zoom))); } };
        
        canvas.ontouchstart = e => {
            if(e.touches.length===1) { isMoving=false; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; }
            else { startDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY); }
        };
        canvas.ontouchmove = e => {
            e.preventDefault();
            if(e.touches.length===1) {
                isMoving=true; viewportX-=(e.touches[0].clientX-lastX)/(40*zoom); viewportY-=(e.touches[0].clientY-lastY)/(40*zoom);
                lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; draw();
            } else {
                const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                zoom=Math.max(0.5,Math.min(3,zoom*(d/startDist))); startDist=d; draw();
            }
        };
        canvas.ontouchend = e => { if(!isMoving && e.changedTouches.length===1) { const r=canvas.getBoundingClientRect(); const t=e.changedTouches[0]; attemptPlace(Math.floor(viewportX+(t.clientX-r.left)/(40*zoom)), Math.floor(viewportY+(t.clientY-r.top)/(40*zoom))); } };
        canvas.onwheel = e => { e.preventDefault(); zoom=Math.max(0.5,Math.min(3,zoom+(e.deltaY<0?0.1:-0.1))); draw(); };
    </script>
</body>
</html>

