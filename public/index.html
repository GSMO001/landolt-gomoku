<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LANDOLT GOMOKU ONLINE</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --danger: #ef4444;
            --board-bg: #064e3b;
            --ui-bg: #ffffff;
            --text: #1e293b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: -apple-system, sans-serif; background: #0f172a; height: 100vh; overflow: hidden; display: flex; justify-content: center; }

        .container { width: 100%; max-width: 550px; height: 100%; background: var(--ui-bg); display: flex; flex-direction: column; position: relative; }

        /* LOBBY STYLE */
        #lobby-screen { flex: 1; display: flex; flex-direction: column; padding: 20px; overflow: hidden; }
        .lobby-header { text-align: center; margin-bottom: 20px; }
        .lobby-header h1 { color: var(--primary); font-size: 26px; }

        .create-form { background: #f1f5f9; padding: 15px; border-radius: 12px; margin-bottom: 15px; flex-shrink: 0; }
        input, select { width: 100%; padding: 12px; margin-top: 5px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #cbd5e1; font-size: 16px; }
        .btn-main { width: 100%; padding: 14px; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }

        .room-search-bar { margin-bottom: 10px; flex-shrink: 0; }
        .room-list-container { 
            flex: 1; overflow-y: scroll; -webkit-overflow-scrolling: touch; 
            border: 1px solid #e2e8f0; border-radius: 12px; background: #fff;
            padding: 5px; touch-action: pan-y;
        }
        .room-item { 
            display: flex; justify-content: space-between; align-items: center; 
            padding: 15px; border-bottom: 1px solid #f1f5f9; transition: background 0.2s;
        }
        .room-item:last-child { border-bottom: none; }
        .room-meta b { font-size: 17px; color: var(--text); display: block; }
        .room-meta span { font-size: 12px; color: #64748b; }
        .btn-join { padding: 10px 18px; background: #10b981; color: white; border: none; border-radius: 8px; font-weight: bold; }

        /* GAME SCREEN STYLE */
        #game-screen { display: none; flex-direction: column; height: 100%; position: absolute; inset: 0; background: white; z-index: 100; touch-action: none; }
        .game-nav { padding: 10px 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; background: #fff; }
        
        #main-canvas-area { flex: 1; background: var(--board-bg); position: relative; overflow: hidden; cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; }

        .game-footer { padding: 15px 20px 40px 20px; border-top: 1px solid #eee; background: #fff; }
        .timer-track { height: 10px; background: #e2e8f0; border-radius: 5px; margin-bottom: 15px; overflow: hidden; }
        #timer-bar { height: 100%; background: var(--primary); width: 100%; transition: width 1s linear; }

        .dir-controls { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px; }
        .dir-btn { height: 60px; border: 2px solid #e2e8f0; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; transition: 0.2s; }
        .dir-btn.active { background: var(--primary); color: white; border-color: var(--primary); transform: scale(0.95); }

        .exit-link { text-align: center; color: var(--danger); font-weight: bold; font-size: 14px; padding: 10px; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <div id="lobby-screen">
        <div class="lobby-header">
            <h1>LANDOLT ONLINE</h1>
        </div>

        <div class="create-form">
            <label style="font-size:12px; font-weight:bold;">„É´„Éº„É†Âêç</label>
            <input type="text" id="room-id-input" placeholder="‰æã: ÁåõËÄÖÊ±Ç„ÇÄ">
            <label style="font-size:12px; font-weight:bold;">„Éë„Çπ„ÉØ„Éº„Éâ (‰ªªÊÑè)</label>
            <input type="password" id="room-pw-input" placeholder="ÁßòÂØÜ„ÅÆÂØæÂ±Ä„Å´">
            <label style="font-size:12px; font-weight:bold;">Âà∂ÈôêÊôÇÈñì (Áßí)</label>
            <select id="time-limit-select">
                <option value="30">30Áßí (È´òÈÄü)</option>
                <option value="60" selected>60Áßí (Ê®ôÊ∫ñ)</option>
                <option value="120">120Áßí („Åò„Å£„Åè„Çä)</option>
            </select>
            <button class="btn-main" onclick="handleCreate()">Êñ∞„Åó„ÅÑ„É´„Éº„É†„Çí‰ΩúÊàê</button>
        </div>

        <div class="room-search-bar">
            <input type="text" id="search-input" placeholder="üîç „É´„Éº„É†„ÇíÊ§úÁ¥¢..." oninput="renderRoomList()">
        </div>

        <div class="room-list-container" id="room-list-target">
            </div>
    </div>

    <div id="game-screen">
        <div class="game-nav">
            <div>
                <b id="display-room-name">---</b><br>
                <span id="display-status" style="font-size:13px; font-weight:bold;">Êé•Á∂ö‰∏≠...</span>
            </div>
            <div id="display-timer-val" style="font-size:28px; font-weight:900; color:var(--primary);">60</div>
        </div>

        <div class="timer-track"><div id="timer-bar"></div></div>
        
        <div id="main-canvas-area">
            <canvas id="game-canvas"></canvas>
        </div>

        <div class="game-footer">
            <div id="pair-stat-ui" style="text-align:center; font-weight:900; color:var(--primary); margin-bottom:10px;">PAIRS: 0 / 0</div>
            <div class="dir-controls">
                <div class="dir-btn active" id="db-0" onclick="changeDirection(0)">‚Üë</div>
                <div class="dir-btn" id="db-1" onclick="changeDirection(1)">‚Üí</div>
                <div class="dir-btn" id="db-2" onclick="changeDirection(2)">‚Üì</div>
                <div class="dir-btn" id="db-3" onclick="changeDirection(3)">‚Üê</div>
            </div>
            <div class="exit-link" onclick="location.reload()">ÂØæÂ±Ä„ÇíÁµÇ‰∫Ü„Åó„Å¶„É≠„Éì„Éº„Å´Êàª„Çã</div>
        </div>
    </div>
</div>

<script>
    /**
     * „Ç≤„Éº„É†ÁÆ°ÁêÜ„ÇØ„É©„Çπ
     */
    const socket = io();
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const area = document.getElementById('main-canvas-area');

    // „Ç∞„É≠„Éº„Éê„É´„Çπ„ÉÜ„Éº„Éà
    let mySide = null; // 0 or 1
    let currentTurn = 0;
    let roomListCache = [];
    let boardState = [];
    let pairHistory = [0, 0];
    let isGameRunning = false;
    let selectedDirection = 0;
    let globalTimeLimit = 60;
    let activeRoomId = "";

    // „Ç´„É°„É©Êìç‰ΩúÔºà„Éû„É´„ÉÅ„Éá„Éê„Ç§„ÇπÂØæÂøúÔºâ
    let camera = { x: 64, y: 64, zoom: 1.0 };
    let isDragging = false;
    let lastTouch = { x: 0, y: 0 };
    let lastPinchDist = 0;

    // --- Lobby Functions ---
    socket.on('lobbyUpdate', list => {
        roomListCache = list;
        renderRoomList();
    });

    function renderRoomList() {
        const target = document.getElementById('room-list-target');
        const query = document.getElementById('search-input').value.toLowerCase();
        target.innerHTML = "";

        const filtered = roomListCache.filter(r => r.id.toLowerCase().includes(query));

        if (filtered.length === 0) {
            target.innerHTML = `<p style="text-align:center; padding:30px; color:#94a3b8;">„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</p>`;
            return;
        }

        filtered.forEach(room => {
            const div = document.createElement('div');
            div.className = 'room-item';
            div.innerHTML = `
                <div class="room-meta">
                    <b>${room.id} ${room.hasPw ? 'üîí' : ''}</b>
                    <span>${room.status} ‚Ä¢ Âà∂ÈôêÊôÇÈñì ${room.timeLimit}s</span>
                </div>
                <button class="btn-join" onclick="handleJoin('${room.id}', ${room.hasPw})">ÂèÇÂä†</button>
            `;
            target.appendChild(div);
        });
    }

    function handleCreate() {
        const id = document.getElementById('room-id-input').value;
        const pw = document.getElementById('room-pw-input').value;
        const time = document.getElementById('time-limit-select').value;
        if (!id) return alert("„É´„Éº„É†Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
        socket.emit('createRoom', { roomId: id, password: pw, timeLimit: time });
    }

    function handleJoin(id, hasPw) {
        const pw = hasPw ? prompt("„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ") : "";
        if (pw !== null) socket.emit('joinRoom', { roomId: id, password: pw });
    }

    // --- Socket Events ---
    socket.on('joinSuccess', data => {
        mySide = data.playerIndex;
        activeRoomId = data.roomId;
        globalTimeLimit = data.timeLimit;
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'flex';
        document.getElementById('display-room-name').textContent = data.roomId;
        resizeCanvas();
    });

    socket.on('gameStartSignal', () => {
        isGameRunning = true;
        refreshUI();
        drawBoard();
    });

    socket.on('tick', data => {
        document.getElementById('display-timer-val').textContent = data.timeLeft;
        const percent = (data.timeLeft / globalTimeLimit) * 100;
        const bar = document.getElementById('timer-bar');
        bar.style.width = percent + "%";
        bar.style.background = data.timeLeft <= 10 ? "var(--danger)" : "var(--primary)";
    });

    socket.on('updateState', data => {
        boardState.push(data.piece);
        currentTurn = data.nextTurn;
        pairHistory = data.consecutivePairs;
        refreshUI();
        drawBoard();
    });

    socket.on('gameOverSignal', data => {
        isGameRunning = false;
        alert(data.reason === "TIMEOUT" ? "ÊôÇÈñìÂàá„Çå„Åß„ÅôÔºÅ" : "ÂãùË≤†„ÅÇ„ÇäÔºÅ");
        alert(data.winner === mySide ? "„ÅÇ„Å™„Åü„ÅÆÂãùÂà©„Åß„ÅôÔºÅ" : "„ÅÇ„Å™„Åü„ÅÆÊïóÂåó„Åß„Åô„ÄÇ");
        location.reload();
    });

    socket.on('opponentLeft', () => {
        alert("ÂØæÊà¶Áõ∏Êâã„ÅåÈÄÄÂá∫„Åó„Åæ„Åó„Åü„ÄÇ„É≠„Éì„Éº„Å´Êàª„Çä„Åæ„Åô„ÄÇ");
        location.reload();
    });

    socket.on('system_error', msg => alert(msg));

    // --- Rendering Engine ---
    function drawBoard() {
        if (!canvas.width) return;
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cellSize = 45 * camera.zoom;
        const offsetX = canvas.width / 2 - camera.x * cellSize;
        const offsetY = canvas.height / 2 - camera.y * cellSize;

        // Áõ§Èù¢ËÉåÊôØ
        ctx.fillStyle = varColor('--board-bg');
        ctx.fillRect(offsetX, offsetY, 128 * cellSize, 128 * cellSize);

        // „Ç∞„É™„ÉÉ„ÉâÁ∑ö
        ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Ë≤†Ëç∑ËªΩÊ∏õÔºöÂèØË¶ñÈ†òÂüü„ÅÆ„ÅøÊèèÁîª„Åô„Çã„É≠„Ç∏„ÉÉ„ÇØÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
        for (let i = 0; i <= 128; i++) {
            ctx.moveTo(offsetX + i * cellSize, offsetY);
            ctx.lineTo(offsetX + i * cellSize, offsetY + 128 * cellSize);
            ctx.moveTo(offsetX, offsetY + i * cellSize);
            ctx.lineTo(offsetX + 128 * cellSize, offsetY + i * cellSize);
        }
        ctx.stroke();

        // Áü≥Ôºà„É©„É≥„Éâ„É´„ÉàÁí∞Ôºâ„ÅÆÊèèÁîª
        boardState.forEach(p => {
            const centerX = offsetX + p.x * cellSize + cellSize / 2;
            const centerY = offsetY + p.y * cellSize + cellSize / 2;
            const radius = cellSize * 0.36;

            // Êú¨‰Ωì
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = p.player === 0 ? "#000000" : "#ffffff";
            ctx.lineWidth = cellSize * 0.11;
            ctx.stroke();

            // Âàá„ÇåÁõÆ
            ctx.beginPath();
            const angle = [-Math.PI / 2, 0, Math.PI / 2, Math.PI][p.direction];
            ctx.arc(centerX, centerY, radius, angle - 0.45, angle + 0.45);
            ctx.strokeStyle = "#fbbf24"; // Âàá„ÇåÁõÆÂº∑Ë™ø
            ctx.lineWidth = cellSize * 0.14;
            ctx.stroke();
        });
    }

    // --- Input Logic (PC & Mobile Áµ±Âêà) ---
    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    // „Éû„É´„ÉÅ„Éá„Éê„Ç§„Çπ„Éª„Ç§„Éô„É≥„ÉàÁµ±Âêà
    const handleStart = (e) => {
        if (e.type === 'touchstart') {
            if (e.touches.length === 1) {
                isDragging = false;
                lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                lastPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            }
        } else {
            isDragging = false;
            lastTouch = { x: e.clientX, y: e.clientY };
            area.isMouseDown = true;
        }
    };

    const handleMove = (e) => {
        if (e.type === 'touchmove') e.preventDefault();
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        if (e.touches && e.touches.length === 2) {
            // „Éî„É≥„ÉÅ„Ç∫„Éº„É†
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            camera.zoom = Math.min(Math.max(camera.zoom * (dist / lastPinchDist), 0.5), 3.0);
            lastPinchDist = dist;
            drawBoard();
            return;
        }

        if (e.type === 'mousemove' && !area.isMouseDown) return;

        const dx = clientX - lastTouch.x;
        const dy = clientY - lastTouch.y;

        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) isDragging = true;

        camera.x -= dx / (45 * camera.zoom);
        camera.y -= dy / (45 * camera.zoom);
        lastTouch = { x: clientX, y: clientY };
        drawBoard();
    };

    const handleEnd = (e) => {
        if (!isDragging) {
            const pos = getPointerPos(e.type === 'touchend' ? e.changedTouches[0] : e);
            processClick(pos.x, pos.y);
        }
        area.isMouseDown = false;
    };

    area.addEventListener('touchstart', handleStart, { passive: false });
    area.addEventListener('touchmove', handleMove, { passive: false });
    area.addEventListener('touchend', handleEnd, { passive: false });
    area.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);

    /**
     * ÁùÄÊâãÂá¶ÁêÜ
     */
    function processClick(screenX, screenY) {
        if (!isGameRunning || currentTurn !== mySide) return;

        const cellSize = 45 * camera.zoom;
        const gridX = Math.floor((screenX - (canvas.width / 2 - camera.x * cellSize)) / cellSize);
        const gridY = Math.floor((screenY - (canvas.height / 2 - camera.y * cellSize)) / cellSize);

        if (gridX < 0 || gridX >= 128 || gridY < 0 || gridY >= 128) return;
        if (boardState.some(p => p.x === gridX && p.y === gridY)) return;

        // „ÄåÂØæ„Äç„ÅÆÂà§ÂÆö
        let isPairMove = false;
        const lastOppPiece = boardState.filter(p => p.player !== mySide).pop();
        if (lastOppPiece) {
            const dx = gridX - lastOppPiece.x;
            const dy = gridY - lastOppPiece.y;
            if (lastOppPiece.direction === 0 && dy === -1 && dx === 0) isPairMove = true;
            if (lastOppPiece.direction === 1 && dx === 1 && dy === 0) isPairMove = true;
            if (lastOppPiece.direction === 2 && dy === 1 && dx === 0) isPairMove = true;
            if (lastOppPiece.direction === 3 && dx === -1 && dy === 0) isPairMove = true;
        }

        // 3ÈÄ£Âà∂Èôê
        if (isPairMove && pairHistory[mySide] >= 3) {
            return alert("ÈÄ£Á∂ö„Åó„Å¶„ÄåÂØæ„Äç„Å´„Åß„Åç„Çã„ÅÆ„ÅØ3Âõû„Åæ„Åß„Åß„ÅôÔºÅ");
        }

        const newPairHistory = [...pairHistory];
        newPairHistory[mySide] = isPairMove ? newPairHistory[mySide] + 1 : 0;

        const newPiece = { x: gridX, y: gridY, direction: selectedDirection, player: mySide };
        
        socket.emit('action_place', {
            roomId: activeRoomId,
            piece: newPiece,
            consecutivePairs: newPairHistory
        });

        // ÂãùÂà©„ÉÅ„Çß„ÉÉ„ÇØ
        if (checkVictory(boardState.concat(newPiece), mySide)) {
            socket.emit('action_win', { roomId: activeRoomId, winner: mySide });
        }
    }

    /**
     * ÂãùÂà©Êù°‰ª∂: 5„Å§‰∏¶„Å≥ Ôºã „Åù„ÅÆ‰∏≠„Å´1„Å§‰ª•‰∏ä„ÅÆ„ÄåÂØæ„Äç
     */
    function checkVictory(board, side) {
        const mine = board.filter(p => p.player === side);
        const vectors = [[1, 0], [0, 1], [1, 1], [1, -1]];

        for (const p of mine) {
            for (const [vx, vy] of vectors) {
                let line = [p];
                for (let i = 1; i < 5; i++) {
                    const next = mine.find(m => m.x === p.x + vx * i && m.y === p.y + vy * i);
                    if (next) line.push(next); else break;
                }

                if (line.length >= 5) {
                    const hasValidPair = line.some(stone => {
                        return board.some(other => other !== stone && isPairRelation(stone, other));
                    });
                    if (hasValidPair) return true;
                }
            }
        }
        return false;
    }

    function isPairRelation(a, b) {
        const dx = b.x - a.x; const dy = b.y - a.y;
        if (dx === 0 && dy === -1) return a.direction === 0 && b.direction === 2;
        if (dx === 1 && dy === 0) return a.direction === 1 && b.direction === 3;
        if (dx === 0 && dy === 1) return a.direction === 2 && b.direction === 0;
        if (dx === -1 && dy === 0) return a.direction === 3 && b.direction === 1;
        return false;
    }

    // --- Helpers ---
    function refreshUI() {
        const status = document.getElementById('display-status');
        if (currentTurn === mySide) {
            status.textContent = "‚òÖ „ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥„Åß„Åô";
            status.style.color = "var(--primary)";
        } else {
            status.textContent = "Áõ∏Êâã„ÅåËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...";
            status.style.color = "#64748b";
        }
        document.getElementById('pair-stat-ui').textContent = `PAIRS: ${pairHistory[0]} / ${pairHistory[1]}`;
    }

    function changeDirection(d) {
        selectedDirection = d;
        document.querySelectorAll('.dir-btn').forEach((btn, i) => {
            btn.classList.toggle('active', i === d);
        });
    }

    function varColor(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function resizeCanvas() {
        canvas.width = area.clientWidth;
        canvas.height = area.clientHeight;
        drawBoard();
    }

    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>




